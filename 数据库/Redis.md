## Redis

#### CAP定理

在理论计算机科学中，CAP 定理指出对于一个分布式计算系统来说，不可能同时满足以下三点：

一致性（Consistency）所有节点访问同一份最新的数据副本，也就是所有节点在同一时间具有相同的数据

可用性（Availability）每次请求都能获取到非错的响应，但不保证获取的数据为最新数据，也就是每个请求不管成功或者失败都会有响应

分区容错性（Partition tolerance）即分布式系统在遇到某节点或者网络分区故障时，仍然能够对外提供满足一致性和可用性的服务；当不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择

三二原则：CAP是没办法同时达到的，要么是CP，要么是AP，是不可能存在CAP的

对于分布式系统，在CAP原则中，P是一定要保证的，如果没有分区容错性那这个系统就太脆弱了，但是两外两个特性C和A就只能选择一个

比如：假如分布式情况下数据库1和数据库2，用户上传一张图片必须同时同步成功才满足**一致性**，并且用户可以看到信息也满足了**可用性**，当突发场景数据库1和数据库2突然间因为网络断电原因，某一个直接宕机，那还有另外一个数据库可以提供分区容错性，但是这时候已经无法满足一致性了



#### Redis基础

##### 1.Redis是什么？

**答：**Redis是一个数据库，不过与传统RDBM不同，Redis属于NoSQL，也就是非关系型数据库，它的存储结构是Key-Value。Redis的数据直接存在内存中，读写速度非常快，因此 Redis被广泛应用于缓存方向

RDBM：Relational Data Base Management



##### 2.Redis的缺点

**答：**1.缓存和数据库一致性问题     2.缓存击穿，缓存穿透，缓存雪崩



##### 2.NoSQL的BASE理论是什么

**答：**和传统事务的ACID截然不同，BASE不追求强一致性，而是允许数据在一段时间内是不一致的，但最终达到一致状态，从而获得更高的可用性和性能

BASE 理论是对 CAP 中 AP 的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态；满足 BASE 理论的事务，我们称之为柔性事务

基本可用 （Basically Available）： 分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网址交易付款出现问题来，商品依然可以正常浏览

软状态（Soft State）： 由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单中的“支付中”、“数据同步中”等状态，待数据最终一致后状态改为成功 状态"

最终一致性（Eventual Consistency）： 最终一致是指的经过一段时间后，所有节点数据都将会达到一致。如订单的“支付中”状态，最终会变为“支付成功”或者“支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待



##### 3.说说你最常用的Redis命令

**答：**我最常用的读操作是 get a，表示获取a对应的数据；最常用的写操作是setex a t b，表示将a的数据设置为b，并且在t秒后过期



##### 4.Redis过期键的清除策略？

**答：**过期键清除策略有三种，分别是定时删除、定期删除和惰性删除

1.定时删除：是在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作

2.定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键

3.惰性删除：是指使用的时候，发现Key过期了，此时再进行删除

Redis的过期键采用的是 定期删除 + 惰性删除 二者结合的方式进行删除的



附：如果过期键没有被访问，而周期性删除又跟不上新键产生的速度，内存不就慢慢耗尽了吗？

**答：**Redis支持内存淘汰，配置参数 maxmemory_policy 决定了内存淘汰策略。这个参数一共有8个枚举值

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image18.png" style="zoom:80%;" /> 





##### 6.内存淘汰使用的是LRU算法吗？

**答：**Redis用的是近似LRU算法，LRU算法需要一个双向链表来记录数据的最近被访问顺序，但是出于节省内存的考虑，Redis的LRU算法并非完整的实现

Redis通过对少量键进行取样，然后和目前维持的淘汰池综合比较，回收其中最久未被访问的键。通过调整每次回收时的采样数量 maxmemory-samples，可以实现调整算法的精度



#### Redis数据结构

##### 1.Redis有哪些数据类型

答：五种基本数据类型：字符串(String)，散列(Hash)，列表(List)，集合(Set)，有序集合(Zset)

三种特殊数据类型：bitmaps，hyperloglogs 和 geospatial 

底层实现依托于sds、ziplist、skiplist、dict等更基础数据结构

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image19.png" style="zoom:50%;" /> 

 

##### 2.Redis的字符有什么特点

**答：**Redis的字符串如果保存的对象是整数类型，那么就用int存储。如果不能用整数表示，就用SDS来表示，SDS通过记录长度，和预分配空间，可以高效计算长度，进行append操作

SDS就是对字符数组封装的一个结构体，里面记录了已经使用的空间大小，未使用的空间大小等数据

附：Redis中的SDS相比于普通的字符串为什么高效？

**答：**从两个角度回答：字符串长度处理和内存空间分配上

1.字符串长度处理：Redis 的 SDS 中会有一个长度字段来记录字符串的长度，而普通的C语言中的字符串想得到字符串的长度只能通过遍历的方式，时间复杂度为O(n);

2.内存分配：对SDS修改以及扩容空间时，除了所分配的空间外，还会额外分配未使用的空间；

具体分配规则为：SDS修改后如果字符串的长度小于1M，那么就会额外分配与字符串长度相同的未使用空间大小；如果修改后长度大于1M，那将分配1M的使用空间

当然有空间分配就会有对应的空间释放，SDS缩短时并不会回收多余的空间，而是使用 free 字段将多出来的空间记录下来；如果后续有变更操作，就直接使用 free 中记录的空间，减少内存分配

总结：SDS 里面记录了字符串的长度，以及已经使用的空间大小，未使用空间大小；所以添加字符的时候能够始终保持后面都有位置存放，也就是在执行 append   操作时不需要重新申请内存，因为如果新申请空间，那就需要把之前的元素全部拷贝到这块新内存中（拷贝元素是很耗时的）



##### 3.Redis中哈希扩容的过程

**答：**我们用装载因子表示散列表的装满程度 ：装载因子α=元素个数/散列表长度

当哈希表的实际装载因子达到默认的负载因子值（负载极限）时，就会触发哈希表的扩容

一般情况下，默认的负载因子值不能太大，因为其虽然减少了空间开销，但是增加了查询的时间成本；也不能太小，因为这样还会增加 rehash 的次数，性能较低

1.两张hash表，平常起作用的都是第一张表，当装载因子超过阈值就会进行Rehash，将第一张表上的每一个bucket慢慢移动到第二张表，所以叫渐进式哈希，这种方式可以减少迁移系统的影响

2.Rehash的过程（渐进式哈希的过程）

1).生成新的一张hash表，为这张新的hash表分配空间；此时字典持有源哈希表和新的哈希表这两张哈希表；字典的偏移索引从静默状态-1，设置为0，表示Rehash正式开始工作

2).迁移源哈希表上的数据到新的哈希表；在Rehash进行期间，每次对字典进行增删改查操作，程序会顺带迁移一个源哈希表上的数据，与此同时，周期函数也会定时更新一批

3).最后两张哈希表的指针对象交换；随着字典操作的不断执行，最终在某个时间节点上，源哈希表上的所有键值对都会被Rehash到新的哈希表上，此时将两张哈希表上的指针对象互换，同时把偏移索引设置为-1，表示Rehash操作已经完成

附：如果字典正在Rehash，此时有请求过来了，Redis会怎么处理？

**答：**针对新增的key，是往新的hash表里面插入；针对读请求，先从原哈希表里找，没有再去新的哈希表里找而针对删除和更新，本质也是先找到位置再进行操作，所以和读请求一样，先在源哈希表里找，再到新的哈希表里找



##### 4.跳表怎么实现的

**答：**跳表本质上是对链表的一种优化，通过逐层跳步采样的方式构建索引，以加快查找速度。如果只用普通链表，只能一个一个往后找。跳表就不一样了，可以高层索引，一次跳跃多个节点，如果找过头了，就用更下层的索引

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image20.png" style="zoom:80%;" />



那每个节点有多少层？

**答：**使用概率均衡的思路，确定新插入节点的层数。Redis使用随机函数决定层数。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，最大层数32层

可以看到，50%的概率被分配到第一层，25%的概率被分配到第二层，12.5%的概率被分配到第三层。这种方式保证了越上层数量越少，自然跨越起来越方便

附：Redis的Zset为什么同时需要字典和跳表来实现？

**答：**Zset是一个有序列表，字典和跳表分别对应两种查询场景，字典用来支持按成员查询数据，跳表则用以实现高效的范围查询，这样两个场景，性能都做到了极致



##### 5.ziplist是什么

**答：**压缩列表 ziplist

ziplist是一种连续，无序的数据结构。压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构

说白了 ziplist 就是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列；它能以 O(1) 的时间复杂度在表的两端提供 push 和 pop 操作

一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用指针连接起来。这种方式会带来大量的内存碎片，而且指针也会占用额外的内存。而 ziplist 却是将表中每一项存放在前后连续的地址空间内，一个 ziplist 整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）

另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储





#### 系统容灾

##### 1.Redis持久化机制

**答：**RDB持久化和AOF持久化，Redis默认使用RDB持久化

1).RDB持久化

RDB (Redis Database) 是快照持久化，存储的是数据的二进制快照文件；所谓快照，在这里指的是某一时刻的内存数据，而持久化则是将这一时刻的数据以二进制形式写入到磁盘里

RDB持久化触发机制：Redis默认是根据用户在指定时间内进行了多少操作在后台自动触发持久化，用户也可手动触发持久化，使用save命令

优点：文件紧凑，占用空间小，恢复速度比较快。同时，由于是子进程fork的模式，对Redis本身读写性能的影响很小

缺点：1.需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了；	2.fork进程的时候，会占用一些资源

RDB文件恢复： 开启自动持久化后，数据会存储到名为 dump.rdb 的文件中；当 Redis 服务器重启时，检测到dump.rdb 文件后，会自动加载进行数据恢复

2).AOF持久化

AOF (Append Only File) 是文件追加持久化；与RDB 不同的是，它是通过保存所执行的写命令来实现的，并且保存的数据格式是客户端发送的命令，也就是AOF中记录了Redis的操作命令，可以重放请求恢复现场，AOF的文件会比RDB大很多

出于性能考虑，如果开启了AOF，会将命令先记录在AOF缓冲，之后再刷入磁盘；数据刷入磁盘的时机根据参数决定，有三种模式：1.关闭时刷入；	2.每秒定期刷入；	3.执行命令后立刻触发

AOF的优点是故障情况下，丢失的数据会比RDB更少

缺点是如果是执行命令后立马刷入，AOF会拖累执行速度，所以一般都是配置为每秒定期刷入，这样对性能影响不会很大。



附：AOF是以追加的方式写文件，那是不是AOF文件会越来越大导致磁盘都装不下？

**答：**不会的，Redis 可以在 AOF 文件体积变得过大时，自动地在后台 fork 一个子进程，专门对 AOF 进行重写；说白了，就是针对相同 Key 的操作，进行合并，比如同一个 Key 的 set 操作，那就是后面覆盖前面

在重写过程中，Redis 不但将新的操作记录在原有的 AOF 缓冲区，而且还会记录在 AOF 重写缓冲区。一旦新 AOF 文件创建完毕，Redis 就会将重写缓冲区内容追加到新的AOF文件，再用新的 AOF 文件替换原来的 AOF 文件

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image21.png" style="zoom:50%;" />





既然RDB持久化和AOF持久化各有自己的优点，所以Redis4之后推出了混合持久化  ( 其实就是RDB和AOF的混合模式 )

1.持久化方式：混合持久化是通过 aof-use-rdb-preamble 参数来开启的。它的操作方式是这样的，在写入的时候先把数据以 RDB 的形式写入文件的开头，再将后续的写命令以 AOF 的格式追加到文件中；这样既能保证数据恢复时的速度，同时又能减少数据丢失的风险

2.那么混合持久化中是如何来进行数据恢复的呢？

在 Redis 重启时，先加载 RDB 的内容，然后再重放增量AOF 格式命令。这样就避免了 AOF 持久化时的全量加载，从而使加载速率得到大幅提升



##### 2.Redis机器挂掉怎么办？

**答：**可以用主从模式部署，即有一个或多个备用机器，备用机会作为 Slave 同步 Master 的数据，在 Redis 出现问题的时候，把 Slave 升级为 Master

利用哨兵模式：哨兵来监测 Redis 服务是否正常，异常情况下，由哨兵代理切换。为避免哨兵成为单点，哨兵也需要多机部署，也就是哨兵之间也需要互相监督

哨兵工作流程

1.哨兵会每隔 1秒钟就向架构中所有的机器去 ping 一下，如果一台机器距离最后一次 ping 命令的时间超过 down-after-miliseconds 配置的值就会被该哨兵标记为主观下线（SDOWN）

2.如果哨兵标记了主服务器为主观下线，接下来他就会去问问其他的哨兵，其他哨兵也会判断一下该主节点是否真正挂掉

3.当有足够多的哨兵 (过半) 都认为主节点挂了，就把主节点改为客观下线 (ODOWN)

4.于是哨兵会选举出一个哨兵leader，哨兵leader会选举出一个从节点作为新的主节点



附：如果Master挂掉，会先择哪个Slave？

**答：**当哨兵集群选举出哨兵Leader后，由哨兵Leader在Redis从节点中选择一个Redis节点作为主节点：

1.过滤故障的节点

2.选择优先级（slave-priority）最大的从节点作为主节点，如不存在，则继续

3.选择复制偏移量最大的从节点作为主节点，如果都一样，则继续；这里解释下，数据偏移量记录写了多少数据，主服务器会把偏移量同步给从服务器，当主从的偏移量一致，则数据是完全同步

4.选择 runid 最小的从节点作为主节点；Redis每次启动的时候生成随机的runid作为Redis的标识



附：上面的哨兵Leader怎么选举来的？

**答：**每一个哨兵节点都可以成为Leader，当一个哨兵节点确认Redis集群的主节点主观下线后，会请求其他哨兵节点要求将自己选举为Leader；被请求的哨兵节点如果没有同意过其他哨兵节点的选举请求，则同意该请求，也就是选举票数+1，否则不同意

如果一个哨兵节点获得的选举票数超过节点数的一半，且大于quorum配置的值，则该哨兵节点选举为Leader；否则重新进行选举

redis 中哨兵模式下的 quorum 的解释如下：

(1). 至少要多少个哨兵一致同意，master进程挂掉了，或者slave进程挂掉了，或者要启动一个故障转移操作

(2). quorum是用来识别故障的，真正执行故障转移的时候，还是要在哨兵集群执行选举，选举一个哨兵进程出来执行故障转移操作

(3). 假设有5个哨兵，quorum设置了2，那么如果5个哨兵中的2个都认为master挂掉了;  2个哨兵中的一个就会做一个选举，选举一个哨兵出来，执行故障转移；如果5个哨兵中有3个哨兵都是运行的，那么故障转移就会被允许执行



##### 3.什么是Redis的pipeline

**答：**Redis 使用的是客户端-服务器（CS）模型和请求/响应协议的 TCP 服务器。这意味着通常情况下一个请求会遵循以下两个步骤：

1.客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应

2.服务端处理命令，并将结果返回给客户端

Redis 客户端与 Redis 服务器之间使用 TCP 协议进行连接，一个客户端可以通过一个 socket 连接发起多个请求命令；每个请求命令发出后 client 通常会阻塞并等待 redis 服务器处理，redis 处理完请求命令后会将结果通过响应报文返回给 client，因此当执行多条命令的时候都需要等待上一条命令执行完毕才能执行，这就会造成性能瓶颈

而管道（pipeline）可以一次性发送多条命令并在执行完后一次性将结果返回，pipeline 通过减少客户端与 redis 的通信次数来实现降低往返时延，而且 pipeline 实现的原理是队列，而队列的原理是先进先出，这样就保证数据的顺序性

需要注意到是用 pipeline 方式打包命令发送，redis 必须在处理完所有命令前先缓存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令越多越好。具体多少合适需要根据具体情况测试

有些系统可能对可靠性要求很高，每次操作都需要立马知道这次操作是否成功，是否数据已经写进 redis 了，那这种场景就不适合



#### 数据一致性

##### 1.如何保证缓存和数据库数据的一致性

**答：**即如何保证Redis缓存和MySQL数据库数据一致性

1).缓存是什么？

缓存在计算机领域是一个非常重要的概念；简单来说，存储的速度是有区别的，缓存就是把低速存储的结果，临时保存在高速存储，以提高查询效率；在数据库场景下，更廉价、高效但可靠性稍低的redis可以给更昂贵、较慢、可靠性强的mysql做缓存

2).为什么需要缓存？

关系型数据库如 mysql，通常支持完整的ACID特性，即原子性、一致性、隔离性和持久性，架构复杂，因而性能普遍较低；高并发的查询需求，会给 mysql 带来很大压力，造成数据库系统的不稳定，同时也容易产生延迟；高并发场景下，直接操作数据库很有可能对数据库进行加锁，导致访问数据库的速度更慢

根据局部性原理，80%的请求会落到20%热点数据上，在读多写少场景下，增加一层缓存非常有助于提升系统吞吐量和健壮性。通常，我们会使用 redis 来作为mysql 的缓存，如果在 redis 缓存中能找到数据，就叫缓存命中，此时就直接用 redis 的数据；如果缓存未命中，那么再从 mysql 读取数据。可以看到，redis 就像一个盾牌🛡️一样，帮助 mysql 分担请求，减轻压力



3).缓存一致性怎么解决？

方案一：等待过期，顺其自然

使用redis的过期时间，mysql更新时，redis不做处理，等待缓存过期失效，再从mysql拉取缓存

这种方式实现简单，但数据不一致的时间会比较明显，具体由你的业务来配置。如果读请求非常频繁，且过期时间设置较长，则会产生很多脏数据

优点：redis原生接口，开发成本低，易于实现；管理成本低，出问题的概率会比较小

缺点：完全依赖过期时间，时间太短容易造成缓存频繁失效，太长容易有较长时间不一致，对编程者的业务能力，有一定要求



方案二：尝试删除，从头再来

在方案一的基础上扩展，不光通过 key 的过期时间兜底，还需要在更新 mysql 时，同时尝试删除 redis，如果删除成功，下次访问该数据，则会直接查询 mysql 的数据，此时再写入redis，就完成了数据同步

这里为什么说是尝试删除呢？因为有了key本身的过期时间作为保障，最终一致性是一定达成的，主动删除 redis 数据只是为了减少不一致的时间，但不能让其成为一个关键路径，影响核心流程

优点：相对方案一，达成最终一致性的延迟更小；实现成本较低，只是在方案一的基础上，增加了删除逻辑

缺点：如果更新mysql成功，删除redis却失败，就退化到了方案一；在高并发场景，业务server需要和mysql、redis同时进行连接，这样是损耗双倍的连接资源，容易造成连接数过多的问题。



方案三：Redis主动更新

在更新mysql之后，redis也要更新，怎么更新呢？

用消息队列！具体来说，是将更新操作交给消息队列，由消息队列保证可靠性，此外再搭建一个消费服务订阅消息队列，来异步更新redis数据

优点：

1.使用消息队列，就相当于将请求投递至信箱，只要投递成功即完成任务，不用关心结果，实现了进一步解耦；

2.消息队列本身具有可靠性，在投递成功的前提下，通过手动提交等手段去消费，可以保证更新操作至少在redis中执行一次

缺点：

1.有时序性问题。举个栗子🌰，两台业务服务器在同一时间发出 a = 1 和 a = 5 两条请求，若 mysql 中先执行 a=1再执行 a=5，则 mysql 中 a 的值最终为5；但由于网络传输本身有延迟，所以无法保证两条请求谁先进入消息队列，最终 redis 的结果可能是1也可能是5，如果是1，mysql 和 redis 中的数据就会产生不一致

2.引入了消息队列，同时要增加消费服务，成本较高；	3.依旧存在消耗更多客户端连接数的问题



方案四：订阅日志，完全解耦

把我们搭建的消费服务作为 mysql 的一个 slave，订阅 mysql 的 binlog 日志，解析日志内容，再更新到 redis。此方案和业务完全解耦，redis 的更新对业务方透明，可以减少心智成本

优点：在同步服务压力不大情况下，延迟较低；和业务完全解耦，在更新mysql时，不需要做额外操作；解决了时序性问题，可靠性强

缺点：要单独搭建一个同步服务，并且引入binlog同步机制，成本较大；同步服务如果压力比较大，或者崩溃了，那么在较长时间内，redis中都是老旧数据



附：保证数据一致性的思想大概可以简述为

1.读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应

2.更新的时候，先删除缓存，然后再更新数据库，这样读的时候就会发现缓存中没有数据而直接去数据库中拿数据了



##### 2.一致性哈希

**答：**传统的hash分片，可以将某个 key 落到某个节点；但是会存在一个问题，当节点扩容或者缩容，路由就会完全被打乱；如果是缓存场景，很容易造成雪崩问题

传统哈希是对服务器的数量取模，然后根据哈希出来的值判断应该将数据缓存到哪一台服务器上

一致性hash是对2^32取模（IPV4最大数量就是2^32，所以这样就能保证对所有的ip地址进行取余时不会重复对应hash环上面的正数）

把2^32想象成一个圆 (这个圆就称为哈希环)，把数据和服务器以相同的哈希函数都映射到同一个hash环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求；这种情况下增加节点只会分流后面一个节点的数据；减少节点，那么请求就会由后一个节点继承；也就是说节点变化操作只会影响到后面一个节点的数据



附：虚拟节点的作用？

**答：**上述理想情况下服务器都均匀的分布在哈希环上，而实际映射可能并不均匀，这就会导致有的服务器处理请求多，有的却处理请求很少；这种情况称为哈希环偏斜

所以由此引入了虚拟节点，虚拟节点是 “实际节点” ( 实际的物理服务器)  在hash环上的复制品，一个实际节点可以对应多个虚拟节点（虚拟节点在哈希环上的位置可以设置），让虚拟节点和实际节点均匀的分布在哈希环上，这样缓存的分布就更加均衡



##### 3.布隆过滤器的实现

**答：**布隆过滤器是一种比较巧妙的概率性数据结构，特点是高效地插入和查询，可以告诉我们某样东西一定不存在或者可能存在

