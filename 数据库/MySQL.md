### 事务

#### 1.数据库事务并发带来的问题以及数据库的隔离级别

**答：**

对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题

脏读：对于两个事务T1,T2；T1读取了被T2更新但还没有提交的字段，之后如果T2回滚，T1读取的内容就是临时且无效的

不可重复读：对于两个事务T1,T2；T1读取了一个字段，然后T2更新了该字段，之后T1再次读取同一个字段，值就不同了

幻读：对于两个事务T1,T2；T1从表中读取了一个字段，然后T2在该表中插入一些新的行，之后如果T1再次读取同一个表，就会多出几行



数据库的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题

一个事务与其他事务隔离的程度称为隔离级别；数据库规定了多种事务的隔离级别，不同隔离级别对应了不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱

MySQL 支持四种隔离级别，其中默认的隔离级别为 RR级别（REPEATABLE READ）

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | :--: | :--------: | :--: |
| read uncommitend（读未提交） |  √   |     √      |  √   |
| read commited（读已提交）    |  ×   |     √      |  √   |
| repeatable read（可重复读）  |  ×   |     ×      |  √   |
| serializable（串行）         |  ×   |     ×      |  ×   |

附：serializable（串行）一般不会使用，他会给每一行读取的数据加锁，会导致大量的超时和锁竞争的问题

附：MySQL默认的隔离级别是RR级别，但是不会出现幻读

**答：**MySQL不会出现幻读，因为当事务A更新了表中的某个字段，此时事务A会获得对这个表的表锁，因为事务A还没有提交，所以事务A获得的锁还没有释放，此时事务B在该表中插入新记录，会因为无法获得该表的锁，就会导致插入操作被阻塞；只有当事务A提交了事务后，释放了锁，事务B才能进行接下去的操作；所以可以说MySQL的RR级别的隔离已经解决了脏读，不可重复读和幻读

锁的粒度越细，代价越高，相比表级锁在表的头部直接加锁，行级锁还要扫描找到对应的行对其上锁，这样的代价是很高的，所以表锁和行锁各有所长

3.数据库的CURD

答：C(create)创建    R(Retrieve) 查询     U(update)修改   D(delete)删除





#### 2.数据库事务中的四个基本要素

**答：**ACID指数据库事务正确执行的四个基本要素的缩写；包括原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)

一个支持事务(Transaction)的数据库系统，必须要具备这四种特性，否则在事务执行过程当中无法保证数据的正确性，交易过程极有可能达不到交易方的要求

(1).原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节；事务在执行过程中发生错误，会被回滚(Rollback)到事务开始的状态，就像这个事务从来没有执行过一样

(2).一致性：在事务开始之前和结束之后，数据库的完整性没有被破坏；比如A账户转给B账户10块钱，不管成功与否，AB账户的总金额是不变化的

(3).隔离性：两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时中间某一时刻的数据

(4).持久性：在事务完成之后，该事务对数据库的更改便持久的保存在数据库之中，并不会发生回滚

由于一项操作通常会包含许多子操作，而这些子操作可能会因为硬件的损坏或其他因素产生问题，因此正确实现ACID并不容易

**A 原子性由undo log日志来保证**，它记录了回滚的日志信息，事务回滚时撤销已经执行成功的sql，他需要记录你回滚的相应日志信息

例如：

1).当你delete一条语句的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据

2).当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行 update 操作

3).当你insert一条数据的时候，就需要记录这条数据的主键，回滚的时候，根据主键执行 delete 操作

**C 一致性**

从数据库层面来讲，数据库通过原子性，隔离性和持久性来保证一致性；但是如果你在事务里面故意写出违反约束的代码，一致性还是无法保证；

比如：你在转账的过程，A账户转钱给B账户，你却故意不给B账户加上金额，那一致性还是无法保证

**I 隔离性由MVCC来保证**

MVCC称为多版本并发控制，实际上就是保存了数据在某个时间节点的快照；因为我们每行数据实际上隐藏了两列，创建时间版本号，过期 ( 删除 ) 时间版本号，每开始一个新的事务，版本号都会自动递增；由于MVCC的原理就是查找创建版本小于等于当前事务版本，删除版本为空或者大于当前事务版本；这样做是为了保证事务读取的数据是在事务开始前就已经存在的，要么就是事务自己插入或者修改的

**D 持久性由内存 + redo log来保证**，mysql修改数据的同时在内存和redo log记录这次操作，事务提交的时候就通过redo log刷盘，宕机的时候就可以从redo log恢复

正如之前说的，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，然后再刷回到磁盘上；此时如果突然宕机，内存中的数据就会丢失

为了解决因为宕机和断电等原因导致的数据突然丢失，我们需要在事务提交前先把数据写入磁盘

但是如果只修改一个页面的一个字节，也要将整个页面刷入磁盘这太浪费资源了；毕竟MySQL读取的一个页面（page）是16kb大小，只修改这一页面的一点点内容就需要将整个页面重新刷入磁盘，这不合理；而且一个事务里面可能会涉及多个数据页的修改，而这些页可能不是相邻的，也就是属于**随机IO**；操作随机IO速度会比较慢

于是引入了redo log来解决上面的问题；当数据做修改的时候，不仅在内存中操作，还会在redo log中记录这次操作；当事务提交的时候，会将redo log日志进行刷盘（redo log一部分在内存中，一部分在磁盘上）；当数据库宕机重启的时候，就会将redo log中的内容恢复到数据库中，再根据undo log 和binlog内容来决定回滚数据还是提交数据

附：MySQL的 binlog 文件和 redolog 文件都是顺序写入磁盘的

**磁盘顺序读写和随机读写的区别：**磁盘读写的基本单位是数据块；当读取第一个block时，要经历寻道，旋转延迟，传输 这三个步骤才能读取完这个 block 的数据；而对于下一个block，如果它在磁盘的某个位置，访问它会同样经历寻道，旋转延时，传输才能读取完这个 block 的数据，我们把这种方式的IO叫做随机IO；但是如果这个 block 的起始扇区刚好在我刚才访问的 block 的后面，磁头就能立刻遇到，不需等待而直接传输，这种IO就叫顺序IO.



#### 3.binlog和redolog以及undolog

**binlog（归档日志）**

binlog是一种数据库server层 (和什么存储引擎无关)，以二进制形式存储在磁盘中的逻辑日志；

binlog记录了数据库所有的DDL和DML操作（不包含select和show这些命令，因为这类操作对数据本身并没有修改），也就是记录所有数据库表结构变更（例如create、alter table）以及表数据修改 (insert、update、delete) 的二进制日志，主从数据库同步用到的都是binlog文件；binlog日志文件有三种模式：

**1.STATEMENT 模式**

内容：binlog 只会记录可能引起数据变更的 sql 语句

优势：该模式下，因为没有记录实际的数据，所以日志量和 IO消耗 都很低，性能是最优的

劣势：但有些操作并不是确定的，比如 uuid() 函数会随机产生唯一标识，当依赖 binlog 回放时，该操作生成的数据与原数据必然是不同的，此时可能造成无法预料的后果

**2.ROW 模式**

内容：在该模式下，binlog 会记录每次操作的源数据与修改后的目标数据，StreamSets就要求该模式。

优势：可以绝对精准的还原，从而保证了数据的安全与可靠，并且复制和数据恢复过程可以是并发进行的

劣势：缺点在于 binlog 体积会非常大，同时，对于修改记录多、字段长度大的操作来说，记录时性能消耗会很严重。阅读的时候也需要特殊指令来进行读取数据

**3.MIXED 模式**

内容：是对上述STATEMENT 跟 ROW 两种模式的混合使用

细节：对于绝大部分操作，都使用 STATEMENT 来进行 binlog 的记录，只有以下操作使用 ROW 来实现：表的存储引擎为 InnoDB，使用了uuid( ) 等不确定函数，使用了 insert delay 语句，使用了临时表

三种写入模式总结：

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image.png" style="zoom:75%;" /> 



**redolog（重做日志）**

redolog就相当于是binglog的中继文件       注：redolog是InnoDB引擎特有的

MySQL的数据是存放在磁盘中的，每次读写数据都需做磁盘IO操作，如果并发场景下性能就会很差

为此MySQL提供了一个优化手段，引入缓存Buffer Pool，以此来缓解数据库的磁盘压力；当从数据库读数据时，首先从缓存中读取，如果缓存中没有，则从磁盘读取后放入缓存；当向数据库写入数据时，先向缓存写入，此时缓存中的数据页数据变更，这个数据页称为脏页，Buffer Pool中修改完数据后会按照设定的更新策略，定期刷到磁盘中，这个过程称为刷脏页

MySQL宕机

如果刷脏页还未完成，可MySQL由于某些原因宕机重启，此时Buffer Pool中修改的数据还没有及时的刷到磁盘中，就会导致数据丢失，无法保证事务的持久性。

为了解决这个问题引入了redo log，它记录的是数据库中每个页的修改，而不是某一行或某几行修改成怎样，可以用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置



redo log 使用了 WAL (Write-Ahead Logging)，它的关键点就是先写日志，再写磁盘（这句话可以理解为先写redolog日志，再写磁盘上的binlog日志），可以将其看成一个能持久化的中间文件，起到 "缓冲" 的作用，并且写入速度还不慢

1.记录更新时，InnoDB引擎就会先把记录写到RedoLog里面，并同时更新内存；同时，InnoDB引擎会在空闲时将这个操作记录更新到磁盘里面

2.如果更新太多 redo log处理不了的时候，需先将redo log部分数据写到磁盘，然后擦除redo log部分数据。redo log类似转盘

这样一来即使刷脏页之前MySQL意外宕机也没关系，只要在重启时解析redo log中的更改记录进行重放，重新刷盘即可



RedoLog有write pos 跟check point，在InnoDB中redo log的大小是固定的，比如当前我有四个文件

write pos ：是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头

check point：是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image1.png" style="zoom:60%;" /> 

附：为什么要 redo log 要设计成这个样子?

**答：**因为 redo log 记录的是对数据页上的修改，如果 buffer pool 中的数据页已经刷到磁盘后，那这些记录就失效了，新日志就会将这些失效的记录进行覆盖擦除，也就是移动 check poin t的位置

可以理解为 redo log 就是防止MySQL突然宕机而导致 buffer pool 里面的数据丢失，所以如果buffer pool里面的数据都刷入到磁盘当中了，那 redo log 中的这部分记录也就不再需要保存了

附：redolog两阶段提交目的是为了让binlog跟redolog两份日志之间的逻辑一致

大概流程为：

1.当执行某个写操作的 SQL 时，引擎将这行数据更新到内存的同时把对应的操作记录到 redo log 里面，然后处于 prepare 状态。并把完成信息告知给执行器

2.执行器生成对应操作的 binlog，并把 binlog 写入磁盘里；然后调用引擎的提交事务接口，变更 redo log 状态为 commit，这样操作就算完成了

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image2.png" style="zoom:75%;" /> 



binlog跟redolog区别总结：

1.redolog 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。

2.redolog 是物理日志，记录的是在**某个数据页上做了什么修改**；binlog 是逻辑日志，用来记录**对数据做了什么修改**，记录的是这个语句的原始逻辑，比如给 ID=2 这一行的 c 字段加1。

3.redolog是循环写的，空间固定会用完；binlog是可以追加写入的。追加写是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



#### 4.MySQL内部结构以及SQL语句执行流程

**答：**MySQL大体上可分为 Server层 和 存储引擎层 两部分

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image4.png" style="zoom:80%;" /> 

Server层：

连接器：TCP握手后服务器来验证登陆用户身份

查询缓存：缓存中存在数据则直接返回，MySQL8.0版本以后已经取消，因为查询缓存失效太频繁，得不偿失

分析器：根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法

优化器：多种执行策略可实现目标，系统自动选择最优进行执行

执行器：判断用户是否有执行权限，将最终任务提交到存储引擎

存储引擎层：负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5版本开始成为了默认存储引擎 (经常用的也是这个)



#### 主从复制

现在MySQL主从架构模式有：一主多从、多主一从、级联复制、主主复制  这四种

主从复制原理：

MySQL 主从复制时有两个很重要的日志文件：binlog（二进制日志文件）   relay log（中继日志文件）

在主从同步的过程中，主库会将所有的操作事件记录在 binlog 中，从库通过开启一个 I/O 线程保持与主库的通信，并在一定时间间隔内探测 binlog 日志文件是否发生改变。如果 binlog 日志发生了变化，主库生成一个 binlog dump 线程向从库 I/O 线程传送 binlog；从库上的 I/O 线程将 binlog 复制到自己的 relay log 中。最终由从库中的 SQL 线程读取 relay log 中的事件重放到从库上

![](https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image11.png) 



主从延迟原因：

1.随机重放

MySQL 主库中写 binlog 的操作是顺序写的，之前我们提到过，磁盘的顺序读写速度是很快的；同样的，从库中的 I/O 线程操作日志的速度效率也是很高的。但是别忘了，还有一个 SQL 线程来进行数据重放，而重放的过程是随机写盘的。到这里你应该就明白了吧，某一时刻 relay log 里的数据来不及重放进从库，就会产生主从延迟的情况

2.主库并发高

知道了从库中 SQL 线程的重放情况，对于主库并发高导致主从延迟肯定就不难理解了。某一时刻，大量写请求打到主库上，意味着要不断对 binlog 进行写入，此时从库中的 SQL 线程就会应接不暇，自然会产生主从延迟

3.锁等待

对于 SQL 单线程来说，当遇到阻塞时就会一直等待，直到执行成功才会继续进行。如果某一时刻从库因为查询产生了锁等待的情况，此时只有当前的操作执行完成后才会进行下面的操作，同理也就产生了主从延迟的情况



主从延迟处理

1.并行复制既然 SQL 单线程进行重放时速度有限，那么能不能采用多线程的方式来进行重放呢？

MySQL 5.6 版本后，提供了一种并行复制的方式，通过将 SQL 线程转换为多个 work 线程来进行重放，这样就解决了主从延迟的问题

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image12.png" style="zoom:67%;" /> 

2.降低主库并发

你可能会说了，我现在用的低版本的数据库，也没法升版本啊，那我怎么整。对于主库并发高的情况，这种方式你只能通过控制并发来解决延迟了，多用用 Redis

3.读主库

对于一些实时性要求高的数据，读主库



#### 5.truncate 和 delete 的区别

**答：**数据库语言有四种：DDL（数据库定义语言）、DML（数据库操作语言）、DQL（数据库查询语言）、DCL（数据库控制语言）

1.truncate 是DDL语句，而 delete 是DML语句

2.truncate 是把整张表 drop 掉，然后重建该表；而 delete 是一行一行的删除，所以 truncate 的速度肯定要比delete 速度快；也就是说 truncate 只能删除整张表，而 delete 可以加 where 条件删除特定的行

3.truncate 不可以回滚，而 delete 可以

4.truncate 会重置自增列，而 delete 不会

附：drop是直接把整个表删除掉，而 truncate 也会把整个表删除掉，但是它会重建该表



#### 6.简述关系型数据库和非关系型数据库的区别及其适用场景

**答：**数据库分为关系型数据库和非关系型数据库

1.关系型数据库

关系型数据库模型是将复杂的数据结构使用较为简单的二元关系（二维表）来表示；在该类型数据库中，对数据的基本操作是建立在一个或者多个表上，可以采用结构化查询语言SQL对数据库进行操作；关系型数据库是目前主流的数据库技术，其中具有代表性的数据库管理系统有：MySQL, Oracle,  SQL Server 等（关系 = 二维表）

关系型数据库如 MySQL，通常支持完整的 ACID 特性，即原子性、一致性、隔离性和持久性，架构复杂，因而性能普遍较低；高并发的查询需求，会给mysql带来很大压力，造成数据库系统的不稳定，同时也容易产生延迟；高并发场景下，直接操作数据库很有可能对数据库进行加锁，导致访问数据库的速度更慢

2.非关系型数据库NOSQL

NOSQL (Not Only SQL) 泛指非关系型数据库；关系型数据库在超大规模和高并发的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题；NOSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题；常见的非关系型数据库系统有 Redis，MongoDB等



关系型数据库的缺点：

1.存储的是行记录：不能存储数组、嵌套字段等数据

2.扩展表结构不方便：操作不存在的列会报错，而增加列又需要执行SQL语句才行；而且修改时需要特别注意，因为更新表会长时间锁表，高并发场景下延时会比较高

3.占用内存高：关系型数据库在对大量数据的表进行统计之类的运算时，占用内存会很高，因为它即使只针对某一列所在的字段进行操作，也会将整行数据从存储设备读入内存

NoSQL数据库的分类：

K-V 存储型：比如 Redis，它可以用 K-V 键值对的方式来存储数据，而存储的值可以有好几种格式，如 string、hash、list、set、bitmap 等。

文档存储型：比如 MongoDB，存储的 JSON 格式的文档，解决了关系型数据库的表约束的问题，比如查询不存在的字段会报错。另外也解决了部分存储格式的问题，因 JSON 可以表示数组，还可以嵌套字段存储

附：关系型数据数据库和非关系数据库各自的应用场景？

**答：**关系型和NoSQL数据库的选型，考虑几个指标，**数据量、并发量、实时性、一致性要求、读写分离、安全性、运维性**等。根据这些指标，软件系统可分成以下几类：

管理型系统，如运营类系统，首选关系型

大流量系统，且多字段、数据量增长快，首选 NoSQL

事务型系统，如库存、交易、转账，选关系型 + 缓存 (关系型和非关系型一起使用)

日志型系统，首选 Elasticsearch

搜索型系统，指站内搜索，非通用搜索，如商品搜索，首选 Elasticsearch。

离线计算，如大量数据分析，首选列式数据库

实时计算，如实时监控，可以选时序数据库，或列式数据库



数据库三大范式：

第一范式：列不可再分

要求数据库中表的每一列都是不可分割的原子数据项；也就是保证每一列不可再分；两列的属性相近或者一样，尽量合并属性一致的列，确保不会产生冗余数据

第二范式：确保数据库中的每一列都和主键相关，而不能只与主键的某一部分相关

也就是保证每张表只描述一件事情，第二范式是建立在第一范式的基础上，满足第二范式必须要先满足第一范式

第三范式：确保数据库中的每一列数据都和主键直接相关，而不是间接相关

数据不能存在传递关系，像a->b->c (a与b相关，b又与c相关) 这样的关系是不符合第三范式的

实际设计中不一定要满足三大范式，因为需要考虑性能的问题；通常关联查询的表不能超过三张

1.考虑商业化的需要和目标，数据库的性能更加重要

2.在规范性能的问题的时候，需要适当考虑以下规范性

3.故意给一些表增加一些冗余字段，这样可以降低关联表的数量，由多表查询变成单表查询



#### 7.数据库引擎MyISAM和InnoDB的区别   

**答：**MyISAM是MySQL5.5版本之前的默认存储引擎，InnoDb是MySQL5.5版本之后的存储引擎

|            | MYISAM                 | INNODB                        |
| ---------- | ---------------------- | ----------------------------- |
| 事务支持   | 不支持                 | 支持                          |
| 数据行锁定 | 不支持行锁，只支持表锁 | 既支持行锁，也支持表锁        |
| 外键约束   | 不支持                 | 支持                          |
| 全文索引   | 支持                   | 不支持（从5.6版本后开始支持） |
| 表空间大小 | 较小                   | 较大，约2两倍                 |
| 读写速度   | 更快                   | 更慢                          |

MyISAM 最致命的一点就是不支持事务，而 InnoDB 支持；所以现在 InnoDB 已经成为我们使用的标配、最主流的存储引擎了

附：MyISAM的读取速度更快，为什么更快

**答：**1.查询的时候，由于InnoDB支持事务，所有会有一个MVCC的比较

2.InnoDB查询的时候如果走索引，如果是非主键索引查询，则查询的时候会有回表操作；而MyISAM只有非聚聚索引

3.锁的损耗：InnoDB既支持行锁，也支持表锁，在检查锁的时候这两种锁都需要检查



**MyISAM存储文件**介绍：

每个 MyISAM 表都以3个文件存储在磁盘上。这些文件的名称以表名开头，以扩展名指示文件类型。

.frm 文件（frame）存储表结构		.MYD 文件（MY Data）存储表数据		.MYI 文件（MY Index）存储表索引

MySQL 里的数据默认是存放在安装目录下的 data 文件夹中（针对windows环境），也可以自己修改

.MYI 文件组织索引的方式就是 B+tree。叶子节点的 value 处存放的就是索引所在行的磁盘文件地址

底层查找过程：

1.首先会判断查找条件 where 中的字段是否是索引字段，如果是就会先拿着这字段去 .MYI 文件里通过 B+tree 快速定位，从根节点开始定位查找；

2.找到后再把这个索引关键字（就是我们的条件）存放的磁盘文件地址拿到 .MYD 文件里面找，从而定位到索引所在行的记录

**InnoDB存储文件**介绍：

一张 InnoDB 表底层会对应2个文件在文件夹中进行数据存储

.frm 文件（frame）存储表结构			.ibd 文件（InnoDB Data）存储表索引+数据

很显然，InnoDB 把索引和数据都放在一个文件里存着了；InnoDB 表里面的数据也是用 B+tree 数据结构组织起来的

.ibd 存储数据的特点就是 B+tree 的叶子节点上包括了我们要的索引和该索引所在行的其它列数据

底层查找过程：

1.首先会判断查找条件 where 中的字段是否是索引字段，如果是就会先拿着这字段去 .ibd 文件里通过 B+tree 快速定位，从根节点开始定位查找；

2.找到后直接把这个索引关键字及其记录所在行的其它列数据返回



### 索引

#### 1.基本概念

索引是帮助MySQL高效获取数据的一种排好序的数据结构

数据库除了数据之外，还会维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引

一般来说索引本身也很大，不可能全部存储在内存中，因此往往索引以文件的形式存储在磁盘上

MySQL索引数据结构：B+Tree (主要)，hash表，二叉树，红黑树



索引分类

1.按照**存储结构**来分有 聚簇索引 和 非聚簇索引

聚集索引：叶子节点包含了完整的数据记录；简单来说就是索引和它所在行的其它列数据全部都在一起；

非聚集索引：对于 MyISAM 来说，它的索引就是非聚集索引。因为它的索引和数据是分开两个文件存的：一个 .MYI 存索引，一个 .MYD 存数据

InnoDB引擎聚集索引只能有一个 ( 也称为主键索引 )，可以有多个非主键索引；

InnoDB 除聚集索引之外的所有索引都叫做二级索引，也称辅助索引；它的叶子节点则不会存储数据，就只存储主键值     非主键索引 = 二级索引 = 辅助索引 

注意：区别 InnoDB 里面的聚集索引和 MyISAM 里面的聚集索引，虽然都叫聚集索引，但是有区别

InnoDB 里面的非聚集索引指的是非主键索引，也就是索引的B+树的叶子节点存储的是主键的值；而 MyISAM 全部都是非聚集索引，叶子节点存储的是磁盘块地址

聚簇索引缺点：

1).如果查询不是用主键查询，那么会有回表操作发生

2).如果主键选择不当，则会经常容易触发聚簇索引的B+树结构旋转，重排乃至分裂等

2.按**类型**（也即是按照表列属性）来分有：单值索引  唯一索引   复合索引   全文索引  （面试被问到答这三个就可以）

单值索引：即一个索引只包含单个列，一个表可以有多个单值索引

唯一索引：索引列的值必须唯一，该列不允许有重复值，但允许有空值；主键索引就是唯一索引的一种，但是主键唯一非空且一张表只能有一个

复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并（使用多个单列索引组合搜索）

全文索引：对文本的内容进行分词，进行搜索

注意区分：MySQL数据读取是按照页 (page) 来读取的，但是磁盘上的数据存储永远是按照块 (block) 来存储的，将 block 称为磁盘的最小存储单位



索引工作原理

假设存在表Test，表的字段分别为：Col 1 和 Col 2，为该表的Col 2 字段添加索引；为了方便理解，假设索引底层用的数据结构是二叉搜索树，则如下图：

![](https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image5.png)

我们都知道，MySQL数据库中的表中的数据是存储在磁盘上的。即该Test表的数据是存储在磁盘上的。如果我们有SQL语句：

```SQL
select col1, col2 from test where col2 = 89;
```

现在要查找 Col 2 = 89 这条记录；CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/O（涉及到磁盘的旋转时间（速度较快）、磁头的寻道时间(速度慢、费时)）

如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col 2 = 34 开始，进行比较，发现不是，继续下一行 ..... 我们当前的Test表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次磁盘I/O才能找到；速度是很慢的

所以，这就是我们为什么要建索引，目的就是为了减少磁盘I/O的次数，加快查询速率。

附：索引如何工作？

**答：**上图中的Test表中，对字段Col2 添加了索引，就相当于在硬盘上为 Col2 维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是（K，V）结构，key 是Col 2，value 是该 key 所在行的文件指针（地址）；比如：该二叉搜索树的根节点就是：（34, 0x07）

现在对 Col 2 添加了索引，这时再去查找 Col 2 = 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）

```sql
34 读到内存, 89 > 34
读 89 到内存，89 = 89, 查找完成
```

找到之后就根据当前结点的 value 快速定位到要查找的记录对于的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了

索引优点：

1.类似于大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本

2.通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗，避免了全表扫描查找数据

索引的缺点：

1.创建跟维护都需要时间

2.创建索引时，需要对表加锁，在锁表的同时，可能会影响到其他的数据操作

3.索引需要磁盘的空间进行存储，磁盘占用也很快

4.当对表中的数据进行 CRUD 的时，也会触发索引的维护，而维护索引需要时间，可能会降低数据操作性能



索引设计的原则不应该：

1、索引不是越多越好。索引太多，维护索引需要时间跟空间

2、频繁更新的数据，不宜建索引

3、数据量小的表没必要建立索引

应该：

1、重复率小的列建议生成索引。因为重复数据少，索引树查询更有效率，等价基数越大越好。

2、数据具有唯一性，建议生成唯一性索引；在数据库的层面，保证数据正确性

3、频繁 group by、order by 的列建议生成索引；可以大幅提高分组和排序效率

4、经常用于查询条件的字段建议生成索引；通过索引查询，速度更快



哪些情况需要创建索引：

1、主键自动创建唯一性索引

2、频繁作为查询条件的字段应该生成索引

3、查询中与其他表关联的字段，外键关系应该建立索引

4、频繁更新的字段不应该建立索引，因为每次更新不仅仅是更新了记录还会更新索引

5、where条件里用不到的字段不创建索引

6、高并发场景下倾向创建联合索引

7、查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度

8、查询中统计或者分组字段

哪些情况不要创建索引

1、表记录太少

2、经常增删改的表

3、某个字段包含许多重复的内容，则为它创建索引没有太大的效果



索引失效的场景：

1、模糊搜索：左模糊或全模糊都会导致索引失效，比如 '%a' 和 '%a%'。但是右模糊是可以利用索引的，比如'a%' 

2、不在索引列上做任何操作 (计算，函数，类型转换)，会导致索失效而转向全表扫描；where子句中也不要使用or 来连接，比如 select * from t where name = ‘sw’ or age=14    

3、不符合联合索引的最左前缀匹配：(A,B,C) 的联合索引，你只where了C或B或只有B,C；  查询需要从索引的最左列开始并且不跳过索引的中间列

4、在使用不等于（ !=, <> ）时无法使用索引会导致全表扫描；is null 和 is not null 也无法使用索引；

隐式类型转换 (也就是字符串不加单引号) 也会导致了索引失效：比如 select * from t where name = xxx ；name 是字符串类型，但是没有加引号，所以是由MySQL隐式转换的，所以会让索引失效

注：建立了索引如果使用全值匹配查找是最快的，也就是直接通过遍历索引得到数据，无需读表；尽量使用覆盖索引 ( 只访问索引的查询 (索引列和查询列一致 ))，减少 select *

附：怎么解决 like 语句 like %aa% 的索引失效的问题？

**答：**使用覆盖索引来查询



1.什么是联合索引

**答：**对多个字段同时建立的索引 ( 有顺序，ABC，ACB是完全不同的两种联合索引 )

2.为什么要用联合索引

**答：**以联合索引 (a,b,c) 为例

1、减少开销：建立这样的索引相当于建立了索引a、ab、abc三个索引；相当于一个联合索引顶三个普通索引，这当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。

2、覆盖索引：同样的有联合索引（a,b,c），如果有如下的 SQL语句

```sql
select a,b,c fromt table where a = xxx and b = xxx;
```

那么 MySQL 可以直接通过遍历索引取得数据，而无需读表 (避免了访问表的数据行)，这减少了很多的随机 IO 操作。减少 IO 操作，特别的随机 IO 其实是InnoDB 主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一

3、索引列越多，通过索引筛选出的数据越少

有1000W条数据的表，有如下 SQL

```sql
select * from table where a = 1 and b = 2 and c = 3;
```

假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合 b=2 and c= 3 的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知

附：何为覆盖索引？

**答：**覆盖索引就是指的在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询；也就是要查询的字段就在索引树上，不需要读表

而要确定一个查询是否是覆盖索引，只需看 explain sql 语句看 extra 选项的结果是否是 "Using index" 即可

注：如果使用覆盖索引，一定要注意select列表中只取出需要的列，不可 select *，因为如果将所有字段一起做索引将导致索引文件过大，查询性能降低



3.请简述MySQL数据库联合索引中的命名规则

**答：**三条规则

1.MySQL联合索引遵循最左前缀匹配规则，即从联合索引的最左列开始向右匹配，直到遇到匹配终止条件

```sql
例如联合索引(col1, col2, col3), where 条件为 col1=`a` AND col2=`b`可命中该联合索引的 (col1,col2) 前缀部分, where 条件为 col2=`b` AND col3=`c` 不符合最左前缀匹配，不能命中该联合索引
```

2.匹配终止条件为范围操作符 ( 如>, <, between, like等 ) 或函数等不能应用索引的情况

```sql
例如联合索引(a, b, c), where条件为 a = `A` AND b > 1 AND c = `C`, 在列b上为范围查询，匹配即终止，只会匹配到a，不能匹配到(a, b, c), 只用到了索引a和b, 注意索引b只用到了排序，没有用到查找
```

3.where条件中的顺序不影响索引命中

```sql
例如联合索引(col1, col2, col3), where条件为col3=`c` AND col2=b AND col1=`a`, MySQL优化器会自行进行优化，可命中联合索引(col1, col2, col3)
```

附：从上面的规则可知最好把最常用的，筛选字段最多的字段放在左侧

总结：老大必须有，中间兄弟不能断；查询从索引的最左列开始并且不跳过索引中间的列



#### 2.什么是回表操作

**答：**解释这个前需要先回答什么是主键索引和非主键索引

主键索引：主键索引在底层的数据存储是通过 B+ 树来实现的；简单来说，就是除叶子节之外的其他节点都存储的是主键值；而叶子节点上存储的是整行的数据

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image7.png" style="zoom:80%;" /> 

非主键索引：除了主键索引外，其它的索引都被称为非主键索引。与主键索引不同的是，非主键索引的叶子节点上存储的是主键的值

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image8.png" style="zoom:80%;" /> 

回表操作：当我们在非主键索引上查找一行数据的时候，此时的查找方式是先搜索非主键索引树，拿到对应的主键值，再到主键索引树上查找对应的行数据；这种操作就叫作回表操作

当然回表操作的前提是查找的字段不在非主键索引树上，要是在非主键索引树上就查找成功直接返回了

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询



附：为什么非主键索引存储的是主键值而不存储具体的数据所在磁盘块地址？

**答：**当对一个 InnoDB 表进行大量增删改后，B+树就会旋转，重排乃至分裂，同一行记录的页地址也就会发生变化；如果非主键索引存储是磁盘块地址，那么一旦导致B+树分裂，这些地址也得同步更新，而且非主键索引可以有多个，多个索引都需要更新维护那效率比较低；而如果存储的是主键的值，那么只需要更新主键索引，而且主键索引只有一个，也就是只需要更新维护这一个即可

附：何为索引下推？

**答：**索引下推就是只有符合条件再进行回表，对索引中的字段进行一个判断，不符合条件的直接跳过；减少不必要的回表操作



#### 3.B树和B+树的区别

**答：**一颗m阶的B+树和B树的差异主要在于  （大话数据P353）

1.有n颗子树的节点中包含n个关键字  (即每个关键字对应一颗子树，而B树中具有n个关键字的节点含有n+1颗子树)

2.所有叶子节点包含全部关键字的信息，以及指向含这些关键字记录的指针，叶子节点本身依关键字的大小顺序连接

3.所有分支节点 ( 非叶子节点 ) 都可以看成是索引，分支节点中仅含其子树中的最大或最小关键字

B+树的磁盘读写代价更低，B+树的查询效率更加稳定，数据库索引采用B+树而不是B树的主要原因是：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有的节点，效率太低



#### 4.MySQL索引为什么使用B+树？

**答：**文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上；而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入

而其他数据结构，比如红黑树，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性

B+tree的磁盘读写代价更低：B+tree的内部结点 (也就是非叶子节点) 并没有指向具体关键字信息的指针 ( 分支节点只记录子树中最大或最小关键字)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了

B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路径。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当



#### 5.何为MySQL主键

**答：**主键唯一且不为空

主键（primary key ）没有着明确的概念定义，其是索引的一种，并且是唯一性索引的一种，且必须定义为 “PRIMARY KEY”，主键不能重复，一个表只能有一个主键

MySQL 中规定自增列必须为主键，在插入时，如果自动增长列没有输入值，则插入的值为自动增长后的值；如果输入的值为0或者null，则插入的值也为自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，则可以直接插入

1.主键一定是唯一性索引，唯一性索引并不一定就是主键

所谓主键就是能够唯一标识表中某一行的属性或属性组，一个表只能有一个主键，但可以有多个候选索引。因为主键可以唯一标识某一行记录，所以可以确保执行数据更新、删除的时候不会出现张冠李戴的错误。主键除了上述作用外，常常与外键构成参照完整性约束，防止出现数据不一致。数据库在设计时，主键起到了很重要的作用

主键可以保证记录的唯一和主键域非空，数据库管理系统对于主键自动生成唯一索引，所以主键也是一个特殊的索引

2.一个表中可以有多个唯一性索引，但只能有一个主键

3.主键列不允许空值，而唯一性索引列允许空值

4.索引可以提高查询的速度

其实主键和索引都是键，不过主键是逻辑键，索引是物理键，意思就是主键不实际存在，而索引实际存在在数据库中，主键一般都要建，主要是用来避免一张表中有相同的记录，索引一般可以不建，但如果需要对该表进行查询操作，则最好建，这样可以加快检索的速度。



#### 6.为什么DBA都建议表中一定要有主键，而且推荐使用整形自增?

1). 为什么要有主键？

**答：**因为 InnoDB 表里面的数据必须要有一个 B+tree 的索引结构来组织、维护我们的整张表的所有数据，从而形成 .idb 文件；如果 InnoDB 创建了一张没有主键的表，那这张表就有可能没有任何索引，则 MySQL会选择所有具有唯一性并且不为 null 中的第一个字段创建聚集索引

如果没有唯一性索引的字段就会有一个隐式字段成为表的聚集索引：而这个隐式字段，就是 InnoDB 帮我们创建的一个长度为 6字节 的整数列 ROW_ID，它随着新行的插入单调增加，InnoDB 就以该列对数据进行聚集

使用这个 ROW_ID 列的表都共享一个相同的全局序列计数器（这是数据字典的一部分）；为了避免这个 ROW_ID 用完，所以建议表中一定要单独建立一个主键字段

2). 为什么主键推荐使用整形自增？

**答：**1.首先整型的占用空间会比字符串小，而且在查找上比大小也会比字符串更快；字符串比大小的时候还要先转换成 ASCII 码再去比较；如果使用自增的话，在插入方面的效率也会提高

2.不使用自增，可能时不时会往 B+tree 的中间某一位置插入元素，当这个节点位置放满了的时候，节点就要进行分裂操作（效率低）再去维护，有可能树还要进行平衡，又是一个耗性能的操作；都用自增就会永远都往后面插入元素，这样索引节点分裂的概率就会小很多。



#### 10.MySQL调优

**答：**从三个方面：SQL语句、表结构、系统配置和硬件

1.优化查询（避免索引失效）

应尽量避免在 where 子句中使用 != 或 <> 操作符，也不要进行 null 或者 is null 判断，也不要使用 or 来连接条件

任何查询也不要出现 select *

尽量减少数据库排序操作以及全表查询，减少CPU使用

2.优化表结构

(1).尽量使用数字型字段

若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了

(2).尽可能的使用 varchar 代替 char；变长字段存储空间小，可以节省存储空间

(3).单表不要有太多字段

(4).避免使用NULL字段，很难查询且占用额外索引空间

3.优化系统配置和硬件

读写分离：只在主服务器上写，只在从服务器上读。对应到数据库集群一般都是一主一从、一主多从；业务服务器把需要写的操作都写到主数据库中，读的操作都去从库查询；主库会同步数据到从库保证数据的一致性

一般 读写分离 的实现方式有两种：代码封装跟数据库中间件



分库分表：分库分表分为垂直和水平两种方式，一般是先垂直后水平

**垂直拆分**是分库分表方案中最为常见的一种方式，大致的核心思想就是，将一堆的统一数据放到其他节点数据库中或者表中进行存储，不同于我们前面主从复制，主从复制是所有节点数据都是一样，而垂直拆分后，是每个节点存储一部分数据

垂直拆分好处：

1).有效解决了单个数据库或者表的数据存储瓶颈

2).有效提高数据查询性能

3).有效提高并发写入性能，因为是可以写到多个库里面了

1、垂直分库：将应用分为若干模块，比如订单模块、用户模块、商品模块、支付模块等等。其实就是微服务的理念 

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image13.png" style="zoom:80%;" /> 



2、垂直分表：如果表字段较多，一般将不常用字段和数据较大的字段做拆分

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image14.png" style="zoom:80%;" /> 

**水平拆分**的核心思想是：将单一数据表数据按照我们约定的某种规则进行拆分到多个数据库和数据表中，我们的关注点是在表数据本身上

水平分表就是要根据具体场景来选择什么字段作为分表字段；比如我们关注表的创建时间，如果我们要查询某个月的关注数据，就可以将某月份数据放进对应月份表中，这样我们就可以根据创建时间来定位到我们数据存储在哪张表里，然后再根据我们的查询条件进行相应的查询

![](https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image15.png) 



附：MySQL分页查询优化

MySql 的分页查询十分简单，但是当数据量大的时候一般的分页就吃不消了

传统的分页查询如下：

```sql
select c1,c2,cn ... from table limit n, m;

-- 如果只给定一个参数，它表示返回最大的记录行数目
select * from table limit 5; --等价于-- select * from table limit 0,5;
```

MySQL 的 limit 工作原理就是先读取前面的n条记录，然后抛弃前n条，再读后面的m条，所以n越大，偏移量也就越大，性能也就越差

分页查询优化：

1.尽量给出查询的大致范围，如：

```sql
select c1, c2, cn from table where id >= 2000 limit 10;
```

2.子查询

```sql
select c1,c2,cn from table where id >= (select id from table limit 2000, 1);
```

3.使用覆盖索引，对经常需要查询的字段建立索引



#### 11.何为SQL注入

**答：**SQL注入即是指 web 应用程序对用户输入数据的合法性没有判断或者过滤不严格，攻击者可以在web应用程序中事先定义好的查询语句的结尾添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息；

​		因为web应用通常都会用到数据库，当需要对数据库中的表进行增删改查操作时，会使用SQL语句连接数据库进行特定的操作；如果在调用SQL语句的方式上存在疏漏，就有可能执行被恶意注入的非法SQL语句

比如，现在有一张员工表，我想查询某个员工的信息

```sql
select * from staff where name = '' or '1' = '1';		-- 这条SQL语句就会把所有的员工信息查询出来
```



