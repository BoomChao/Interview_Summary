### 关键字

#### **static关键字**

1.static有什么用途？

**答：**对结构化程序设计(不涉及面向对象)，可以说static主要用于变量

**1.对变量而言：**针对局部变量和全局变量   （谭浩强P202）

1).对局部变量：有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放，在下一次再调用该函数时该变量已有值(就是上一次调用结束时的值)，则这时可以指定将该局部变量使用static关键字声明为静态局部变量；

2).对全局变量(也叫外部变量)：有时在程序设计时希望某些全局变量只限于被本文件引用，而不能被其他文件引用，这时可以在定义外部变量时加一个static声明；  （谭浩强P208）

总结：对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间不释放，其所分配的空间始终存在；对全局变量用static声明，则该变量的作用域只限于本文件内(即被声明的文件中)

**2.对函数而言：**

1.在函数返回值类型前加上static，函数就定义为静态函数；函数的定义和声明默认情况下都是extern的，但静态函数只是在声明它的文件中可见，不能被其他文件引用静态函数只能在声明它的文件中可见，其他文件不能引用该函数；不同的文件可以使用相同名字的静态函数，互不影响注意：静态函数只在声明它的文件中可见，所以静态函数只能放在.cc文件中，不能放在.h文件中

2.非静态函数可以在另一个文件直接引用，甚至不必使用extern声明



对面向对象程序设计，可以说static主要作用于类的成员

**对类而言：**静态成员是解决同一个类的不同对象之间的数据和函数共享问题的     （郑莉P154）

1).类的静态数据成员：如果某个属性为整个类所公有，不属于任何一个具体对象，则采用static关键字来声明其为静态成员

2).类的静态函数成员：采用静态函数成员的好处是可以直接访问静态数据，而不依赖于任何对象



42.C++中类里面的static变量和普通的成员变量有什么区别，static函数又与普通的成员函数有什么区别？

44.静态成员函数能访问普通成员变量和静态成员变量吗？普通成员函数能访问普通成员变量和静态成员变量吗？

**答：**类中static声明的变量是属于这个类的，而不属于任何一个具体对象，也就是任何一个对象都能访问到这个静态成员变量；而普通的成员变量是从属于具体的一个对象

静态成员函数通常是专门用来访问类中的静态成员；如果需要访问非静态成员(也就是普通成员)，必须要借助对象名，**这是因为对静态成员函数的调用是没有目的对象的** (因为静态成员是针对类的，不是针对对象)，因此不能向非静态成员函数那样，隐含地通过目的对象访问类的非静态成员  （郑莉P157）

```c++
class A {
   public：
       static void f(A a);
   private:
       int x;
};
void f(A a) {
   std::cout << x；    //这是错误的
   std::cout << a.x；  //正确，静态成员函数访问非静态成员必须借助对象名
}
```

普通成员函数既可访问普通成员变量，也可访问静态成员变量



2.类中的static成员变量怎么初始化，static const 和const static 成员变量怎么初始化？

**答：**类中的static成员变量在类内只做声明，在类外进行初始化(需要使用类名限定)     参考(郑莉P155)

类的静态成员变量在类内声明，但初始化必须放在类外的原因是需要这种方式单独为它分配内存

类的静态成员函数在类内声明，可以在类内初始化也可以在类外初始化；

静态成员函数和普通成员函数一样都是存放在代码段，但是静态成员函数的好处是直接可以用类名来访问，不必通过对象，所以类的静态成员函数通常用来访问静态成员变量

static const 和 const static一个是静态常量，一个是常量静态；都是静态变量，都存储在静态存储区，所以既可以放在类外进行初始化也可以在直接在类内进行初始化

即static const 和 const static 都是指的一个东西，两个同时出现修饰变量时，无论 static 在前 const 在后，还是const 在前 static 在后没有任何区别；即 static const = const static

static const成员，其const属性表示其可以在类内初始化，其static属性表示其为所有对象，可以在类外初始化；所以static const 成员既可以放在类外进行初始化也可以在直接在类内进行初始化

```c++
class Test {
   private:
   static const int num;  /* =10 */       
   //num可以直接在这里初始化，也可以放在类外 const int Test::num = 10；需要使用类名限定，而且要加const修饰符
    
   static int num3;                       //必须放在类外进行初始化，int Test::num3 = 30;  因为需要这种方式专门为其分配存储单元
   const int num4;                        //只能在构造函数初始化列表中初始化，或者在类内定义的时候就初始化, const int num4 = 40;
   
   public:
   Test(int x) : num4(x) { }    //在构造函数初始化列表中初始化num4
};
```



#### 宏#define

1.define定义的变量在预处理阶段就会被直接替换掉(无脑替换)；define不仅可以定义常量，还可以定义函数

2.define不受作用域约束，只要是在宏定义后的语句对宏的使用都是正确的

3.define不是语句，不能在句尾加分号 ";"

4.宏是与类型无关的，能够增强代码的复用性，宏比函数在程序的规模和速度上面更胜一筹，可以提高性能，因为其在预处理阶段就替换掉，省去了函数调用的开销

5.没有类型安全的检查，因为宏与类型无关（类型是指一段内存在不同的地方，会被强制要求使用相同的办法来解释(内存中的数据使用类型来解释的) )，C语言不是类型安全的，因为同一段内存可以用不同的数据类型来解释，比如1用int来解释就是1, 用bool型解释就是true

6.宏可能会带来运算符优先级的问题，导致程序容易出错

```c++
#define Max(a, b) { a > b ? a : b }    
int a = 2, b = 1;
max = Max(a++,b);
我们期望a的结果是3，但是最后结果是4
```

7.过多的宏使用会导致代码可读性差，而且会使得代码体积增大

8.不方便调试 (因为预编译阶段进行了替换)

附：宏的优点：含义清楚，看宏名就可以大致猜测出这个变量的作用；在需要改变程序中多出用到的同一变量时，能做到 "一改全改"

C++有哪些技术可以替换宏？

**答：**1.在常量定义方面换用 const     2.在函数定义方面，换用内联函数 inline



9.宏定义与模板的比较？宏定义会有什么潜在的问题？宏有类型检查吗？

**答：**宏定义和模板的比较

1.宏是在预处理阶段处理，而模板是在编译阶段处理

2.宏不会进行类型检查，只会单纯的进行文本替换，模板会进行类型检查；

3.宏可以直接替换就可以产生目标代码(即.o文件)，而编译器在遇到模板定义时并不产生代码，只有当模板实例化后才会产生目标代码 (模板函数实例化是在编译阶段，编译器会根据其他文件的引入情况来实例化该模板函数)



附：宏的优点和缺点

优点：

1.宏是与类型无关的；  即 #define sum(x) (x + x)  //注意：后面没有";"号

2.增强代码的复用性

3.宏比函数在程序的规模和速度上面更胜一筹，可以提高性能

缺点

1.不方便调试(因为预编译阶段进行了替换)

2.代码可读性差，可维护性差（因为每个人定义的宏名只有往往只有自己知道代表什么）

3.没有类型安全的检查，因为宏与类型无关（类型是指一段内存在不同的地方，会被强制要求使用相同的办法来解释(内存中的数据使用类型来解释的) )，C语言不是类型安全的，因为同一段内存可以用不同的数据类型来解释，比如1用int来解释就是1, 用bool型解释就是true

4.宏可能会带来运算符优先级的问题，导致程序容易出错，比如：

```C++
#define Max(a, b) { a > b ? a : b }  //注意：后面没有";"号
int a = 2, b = 1;max = Max(a++,b);	 //我们期望a的结果是3，但是最后结果是4
```



#### inline关键字

1.什么是内联函数？什么情况需要使用内联函数？

**答：**对一些功能简单，规模又小但使用很频繁的函数，可以设计为内联函数，在函数名前面加上inline关键字；内联函数是在编译时将函数嵌入在每一个调用处，这样就节省了参数传递，控制转移 (控制转移就理解为调用即可) 的开销；有利于提高效率

```C++
class Test {
private:
    int i, j;
public：
    int add() { return i + j; }
    inline int sub() { return i - j; }
    int getNum();
};

inline int Test::getNum() {
    return i;
}
```

上面声明的三个函数都是内联函数

1.在C++中，在类的内部定义了函数体的函数，被默认是内联函数，而不管是否有inline关键字

2.如果函数的定义放在了类的外部，函数定义前必须加inline才能成为内联函数，而函数声明前加不加都无所谓

3.关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前不起任何作用

所以可以说inline是一种用于实现的的关键字，而不是一种用于声明的关键字；



附：引入内联函数的目的是为了解决程序中函数调用的效率问题

函数是一种更高级的抽象。它的引入使得编程者只需要关心函数的功能和使用方法，而不必关心函数功能的具体实现；函数的引入可以减少程序的目标代码，实现程序代码和数据的共享，但是函数调用也会带来降低效率的问题，因为调用函数实际上会将程序执行顺序转移到函数所存放在内存中的某个地址，将函数中的代码执行完后，再返回到执行该函数前的地方。这种转移操作要求在转移前要保护现场并记忆执行的地址，转移后 ( 也就是函数调用完成后 ) 要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响程序执行效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题尤为重要；引入内联函数实际上就是为了解决这一问题



#### typedef关键字

typedef用于将变量名提升为类型 (或者为类型起别名)

特点：

1.与宏不同，typedef有自己的作用域

2.typedef在编译阶段有效，而且有类型检查的功能

3.typedef可以用来定义类型的别名，定义与平台无关的数据类型，配合与struct结构体的使用

```c++
1.typedef可用作声明多个指针型的对象
typedef char* Pchar;    
Pchar pa, pb;    则pa和pb都是字符类型的指针变量

2.用来C语言里辅助struct
如果不用typedef，则定义一个结构体对象时，都要加上struct关键字
typedef struct Node {        //也可以写成 typedef struct {
    int value;
    Node *next;
} Node;

3.用typedef来定义与平台无关的数据类型
如：定义了一个叫REAL的浮点类型，在平台一上，让它表示最高精度的类型为：typedef long double REAL;
在不支持long double的平台上，改为 typedef double REAL;
在连double都不支持的平台上，改为 typedef float REAL;
也就是说在跨平台时，并不需要改变我们的源代码，只需改变用作别名的类型即可

4.为复杂的声明起一个简单的别名，有助于理解和使用，还有助于程序员清楚的知道使用该类型的真正目的
```

C语言的typedef和C++里面的using的作用是一样的，只不过typedef是别名在后面，而using是别名在前面

附：解释typedef void(*pFunc)(void)     

```c++
typedef void(*pFunc)(void)     是函数指针的类型定义，作用是声明一个void(*)( ) 类型的函数指针 pFunc
使用举例：
typedef void (*pFunc)(void);    //现在pFunc就是一个函数指针类型了，这个指针指向参数为void,返回值为void的函数
void myfunc(void);
pFunc pfun = myfunc;           //赋值 (数组名代表数组首地址，函数名代表函数入口地址)
pfun( );                        //通过函数指针调用函数

附：函数指针
voi(*pFunc)(void);    //声明一个参数为void,返回类型为void的函数指针
void fun(void) { cout << "hello" << endl; }
pFunc = fun;        //函数名代表函数首地址，赋值给函数指针
pFunc();            //利用函数指针调用函数
(*pFunc)();         //这种调用和上面这种调用都可以
```

附：使用函数指针的好处在于：使用函数名只能调用一个函数， 而通过指针变量调用函数比较灵活，可根据不同情况先后调用不同的函数《谭P268》

附：typedef的核心用一句话概括就是将变量名提升为类型 (或者为类型起别名)

所以如果问typedef后面的变量是什么意思，比如上面的 typedef void(\*pFunc)(void)；这里的变量名是 pFunc，类型是 void(*)(void)，所以以后pFunc就是指代这个函数指针类型

再如：typedef int a[10];  这里的变量名是a；类型是一个int [10]的数组，所以以后a就指代这个int数组类型



#### 强制类型转换

8.说一说C++中的四种cast转换     （郑莉P244） 

**答：**四种cast转换分别为 static_cast, reinterpret_cast, const_cast, dynamic_cast     

注：这四种转换能不用就不要用，使用时后面的参数必须带有括号( )，前面不需要加 std::；因为其干扰了正常的类型检查

1.static_cast只能用于将一种基本数据类型转换为另一种数据类型 (如整形，字符型，浮点型之间的转换) 或者转换空指针(void *)，或者父类与子类指针的上行和下行转换

不能用于**不同类型的指针**之间互相转换 ( 但可以将其他类型的指针转化成泛型指针，或者泛型指针转化成其他类型的指针，或者基类与子类的指针之间的上行或者下行转换 )

不能用于整形和指针之间的互相转换，也不能用于不同类型引用之间的转换

```c++
double x = 1.2;    int y = static_cast<int>(x);                 //正确，将double转化为int
double *p = &x;    int *ptr = static_cast<int*>(p);             //错误，不能将double* 转换为int*
void *p = &x;      int *ptr = static_cast<int*>(p);             //正确，可以将void*转换为int*
```

2.const_cast用于将对象的常量性擦除，使常量可以被修改；但注意 const_cast\<type>(variable) 中的 type 必须是指针，引用或者指向对象类型成员的指针

```c++
const int a = 3;   const_cast<int>(a) = 4;    //这是错误的
const int &a = 3;  const_cast<int&>(a) = 4;   //这时编译就可通过，且a的值变更为4
```

const_cast只能作用于顶层const，也就是说只能转换常指针指或者引用

常量指针转化成非常量的指针，并且仍然指向原来的对象

常量引用转化成非常量的引用，并且仍然指向原来的对象

```c++
const int val = 12;
int new_val = const_cast<int>(val);     //错误，const_cast只能转换指针或者引用

const int *p = &val;
int *ptr = const_cast<int*>(p);        //正确，将常量指针转化成非常量指针赋值给一个普通类型指针，并仍然指向原来的对象

const int &r = value;
int &re = const_cast<int&>(r);        //正确，将常量引用转化成非常量引用，并仍然指向原来对象
```

注意：使用const_cast把一个原本const常量转化成非const常量是一个未定义行为 (未定义是指这个语句在C+++里面没有规定，由编译器来决定如何处理)

```C++
const int val = 21;
const int &r = val
int &re = const_cast<int&>(r);
re = 3;
//这时 val=21, r = 3, re = 3; 可以看出引用r的值改变了，但是r还是指向val的，val的值没有改变；这就是未定义
```

可以看出在C++里面添加了const关键字的变量就永远都是常量，不用担心其他机制会改变其值；但是对于未定义行为要尽量避免

3.dynamic_cast用于动态类型转换；只能用于含虚函数的类，用于类层次间的向上或向下转化，只能转换指针或引用；

将基类的指针或者引用安全的转化成派生类的指针或引用，**并用派生类的指针或者引用去调用非虚函数**；如果基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数

动态类型转换运行时有类型安全检查 (转换失败返回NULL)，基类必须有虚函数，保持多态性才能用dynamic_cast   （C++primer P730） 

```c++
dynamic_cast<type*>(e)
dynamic_cast<type&>(e)
dynamic_cast<type&&>(e)
```

在上面的三种形式中，e的类型必须是以下三个条件中的任意一个：

1).e的类型是目标type的公有派生类     2).e的类型是目标type的共有基类     3).e的类型就是目标type的类型

如果转换的是指针并且失败了，则返回0

如果转换的是引用并且失败了，则抛出一个bad_cast异常

在类的层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的，在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全

注：

1).如果类中不包含有虚函数，则类层次间的指针转换只能使用static_cast来进行

2).除去dynamic_cast转换是在运行期确定，其他三种强制转换都是在编译期间确定

4.reinterpret_cast用于**将一种类型的指针转换为另一种类型的指针**；

```c++
int i = 2;  float *p = reinterpret_cast<float*>(&i);
```



10.如果我new一个基类指针(有虚函数)，将其下行转换至派生类指针，此时调用它去使用派生中的方法可以吗？

**答：**如果基类指针指向的是派生类对象，则可以，但是如果基类指针指向的是基类对象就不可以；含有虚函数的基类指针的下行转换一定要检查转化后的返回值

dynamic_cast 下行转换是安全的，也就是说如果基类指针或者引用确实指向一个派生类对象，这个运算符会传回适当转型过的指针；如果下行转换不安全（也就是基类指针指向的是基类对象），这个运算符会传回空指针

但是如果基类指针指向的是基类对象，使用static_cast进行下行转换也能转换成功，但是转换后的结果是未定义的

```C++
class Base {
public:
    Base(): b(1) {}
    virtual void print() { std::cout << b << std::endl; 
    int b;
};

class Son : public Base {
public:
    Son(): s(2) {}
    void print() { std::cout << s << std::endl; }
    int s;
};

Base *b = new Base;
Son *s = dynamic_cast<Son*>(b);
//这是基类指针指向基类对象,这不是多态,下面的指针s返回为空,dynamic_cast的下行转换是安全的
//所以多态类型之间的下行转换一定要使用dynamic_cast
if(s == nullptr) cout << "Fail" << std::endl;
    
Base *b = new Son;                        //这是多态，转换成功
Son *s = dynamic_cast<Son*>(b);        
s->print();                               //输出2

Base *b = new Base;                      //基类指针指向基类对象，没有派生类对象实例化，何来的能力去调用派生类的成员
Son *s = static_cast<Son*>(b);           //使用static_cast，也能转换成功，但是结果是未定义的,基类不含有成员s,下面的输出语句输出垃圾值
s->print();
    
Base *b = new Son;                       //基类指针指向派生类对象，则这个派生类对象也会被实例化出来，之后就可以转换指针去操作派生类对象的成员
Son *s = static_cast<Son*>(b);
s->print();      						//输出2
```

11.C++派生类指针强制转换成基类指针会有什么问题吗？

**答：**C++在将一个派生类指针转换成基类指针的过程中，派生类的一部分将被基类接收不到，只能留下基类大小的对象，因为在将派生类的指针传给基类之后，就将派生类的大小看作是基类的大小，所以就只能访问派生类中基类的部分，这种现象称为对象切片(object slicing)，这是C++特有的一种编码错误；但这种错误不是语法错误，而是一个与指针类型有关的问题

12.说一下类型转换，static_cast和C语言的强制转换有啥区别呢？为什么还需要定义这个static_cast?

**答：**static_cast强制转换后在编译时会进行类型检查，而C语言中的强制转换则不会；所以static_cast比C语言强制转换安全

```c++
//定义三个类A，B，C,  C与B有继承关系
class A  { int a; };
class B  { int b; };
class C : public B { int c };

A *a = new A;    B *b = new B;
C *p = (C*)a;                    //编译不会报错
C *p = static_cast<C*>(a);       //编译报错, A和C无任何关系，这种无关联类之间的指针的转换是不正确的

C *p = (C*)b；或者 C *p = static_cast<C*>(b);  //这都是正确的，因为C是B的派生类；将基类指针转换为派生类指针这是可以的
```



#### class和struct以及union关键字

1.class和struct的区别

**答：**C++里面class和struct就两点区别

1).默认的访问权限：struct中未指定访问控制属性的成员其默认访问控制属性是公有的(public)，在class中未指定访问控制属性的成员默认其访问控制属性是私有的(private)

2).默认的继承权限：如果不明确指定，则来自class的继承按照private处理(私有继承)，来自的struct的继承按照public处理(公有继承)

除去上述两点区别，C++中的struct和class没有任何其他区别，结构体也可以有自己的构造函数和析构函数，也具有继承，多态等属性补充：既然C++有了class, 为什么还要引入结构体(struct)，原因在于为了保持和C语言的兼容性



2.C语言的struct和C++struct的区别

**答：**

1).C的struct内不允许有函数存在，C++的struct允许有内部成员函数

2).C的struct对内部成员的访问权限只能是public，而C++的struct允许是public，protected，private三种

3).C语言的struct是不可以继承的，C++的结构体是可以有继承和派生的

4).C++中的struct不再需要typedef，在定义对象时也可以省略struct关键字



3：什么是union

**答：**union称为共用体或者联合体

1).在存储多个成员信息时，编译器会自动给struct每个成员分配存储空间，struct可以存储多个成员信息，而union每个成员会共用一块存储空间；也即是结构体变量所占的长度是各成员所占的内存长度之和，每个成员分别占有其自己的内存单元；  而共用体变量所占的长度等于最长的成员的长度；

2).二者都是可以由多个不同的数据类型成员组成，但在任何同一时刻，union只存放了一个被先选中的成员，而结构体的所有成员都存在

3).对于union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了；而对struct的不同成员赋值是互不影响的

附：struct初始化方式

C语言里面的struct的初始化只有一种方式

```c++
struct stuinfo {
   char *name;
   int age;
};
struct stuinfo students[2] = {{"xiaowang",12}, {"xiaoli",22}};
```

C++里面的struct初始化有两种方式

方法一：按照C里面的方式     方法二：利用构造函数

```c++
struct stuinfo {
   std::string name;
   int age;
   stuinfo() {}
   stuinfo(std::string m_name, int age) : name(m_name), age(m_age) {}
};
stuinfo students[2] = {{"xiaowang", 12}, stuinfo("xiaoli", 22)}；
```



#### const关键字

特点：const可以用来**定义常量**、**修饰函数参数**，**修饰函数返回值**三个作用；被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性

1.const有数据类型检查，const常量替换是在编译阶段，const放在变量前面或者函数参数前面表明所修饰的对象在程序执行过程中不允许被修改

在类成员函数前面加上const和后面加上const分别有什么作用？

1).const放在函数名前面是返回值不可修改，通常针对的是函数返回值为指针类型，如果返回值类型为const类型的指针，则也必须用const修饰的同类型的指针来接受该函数参数

```c++
1.返回值为指针类型        //注意不要返回一个局部对象的地址
const char* getString(*ptr) {
    return ptr;
}
char str[] = "abc";
char *p = getString(str);        //错误：返回的是const类型指针,必须用const类型接收
const char *p = getString(str);  //正确

2.返回值为非指针类型;也就是函数返回值采用值传递方式，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何意义
int getInt(void);    不要写成    const int getInt(void);
```

2).const放在类成员函数的参数列表后面表示访问的类成员的数据不可修改；任何不会修改数据成员的成员函数都应该声明为const类型

注意：const是函数类型的一个组成部分，因此在函数的定义部分也要带上const

```c++
在类R中声明了 void print() const;
在类外定义时为：void R::print() const {};
```



问：const int *p 和 int *const p的区别？指向常量的指针变量和常指针变量？

**答：**1.指向常量的指针变量：即不能改变指针指向的值  (郑莉P202)

const int *p1声明了一个指向整形常量的指针p1，因此不能通过指针p1来改变它所指向的整形值；但是指针p1的指向是可以改变的；p1也称为底层const

2.指针变量的值是常量：即指针一旦指向某个变量就不能再改变其指向（这种指针叫做常指针变量，简称常指针）

int *const p2声明了一个指针型常量，用于存放整形变量的地址，这个指针一旦初始化就不能被重新赋值了，即不能再指向其他变量；但是指针p2指向的值是可以改变的；p2也称为顶层const

```c++
int a = 12, b = 15;
const int *p = &a;	//底层const
*p = b;				//错误
p = &b;				//正确:指向常量的指针变量，不能通过该指针来修改指向变量的值，但是指针指向可以改变

int* const q = &a;  //顶层const
*q = b;				//正确:常指针可以通过该指针改变其指向变量的值,但是指针指向不能改变
q = &a;				//错误
```

附：对指针而言，顶层const表示指针本身是一个常量，底层const表示指针指向的对象是一个常量 (《Primer》P57）

更一般的，顶层const可以表示任意的对象是常量

附：当用实参初始化形参时，会忽略掉形参顶层const；也就是当形参有顶层const时，传给它常量对象和非常量对象都是可以的

如：func(const int i); 	 //func能够读取 i ，但是不能向 i 写值

如果再定义一个函数 func(int i); 

上述两个函数不能算是函数重载（函数重载需要参数列表有明显区别）；因为在传参的过程中，形参的const被忽略掉了，所以上述两个函数可以传入相同的参数，故编译器会报错

函数传参可以忽略掉顶层const，但是底层const是忽略不掉的



问：用const声明的常量类对象能调用成员函数吗？

**答：**const对象只能调用const成员函数，不能调用非const成员函数

因为对类的成员函数的调用都是隐含的通过this指针来调用的，对于常对象，也就是this指针为const类型，而对非const成员函数的调用是使用的普通的 this 指针，不能把一个const类型的指针赋值给一个普通类型指针，所以不能调用非const成员函数；能调用 const 成员函数是因为 const 成员函数使用的是 const 类型的 this 指针



constexpr和const的区别：

**答：**两者都代表只读，const只表示 read only 的语义，保证的是程序运行过程中该变量不可被修改

constexpr是C++11新增的关键字，其语意是 "常量表达式"

常量表达式 是指值不会改变并且在编译过程中就能得到计算结果的表达式；最常见的的常量表达式就是字面值

C++11允许将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式；声明为constexpr的变量一定是一个常量并且必须用常量表达式来初始化

```c++
constexpr int mf = 20;          // 20是常量表达式  
constexpr int limit = mf + 1;   // mf+1是常量表达式
constexpr int sz = size();      // 只有当size是一个constexpr函数时才是一个正确的声明语句
```

constexpr 不仅可以修饰变量还可以修饰函数，constexpr 函数是指能用于常量表达式的函数

注意：用 constexpr 修饰的函数返回类型及所有的形参类型都必须是字面值类型，而且函数体有且仅有一条 return 语句

执行初始化任务时，编译器会把对 constexpr 函数的调用替换成结果值；为了能在编译过程中随时展开，constexpr 函数被隐式指定为内联函数

constexpr的优点：

1.是一种很强的约束，更好的保证程序的正确语义不会被破坏

2.编译器可以在编译期间对constexpr的代码进行非常大的优化，也就是直接将用到的constexpr表达式都直接替换成最终结果

总结：

constexpr修饰的值才是真正的常量，它的值会在编译期间就会被计算出来，整个运行过程中都不可以被改变；constexpr也可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：

```c++
constexpr int func(int i) {
  return i + 1;
}
int main() {
  int i = 2;
  func(i);    // 普通函数
  func(2);    // 编译期间就会被计算出来
}
```

C++规范在一些地方要求使用常量表达式，如声明数组的维数，但是如果我们又不想直接用一个字面值来指定数组的维度，这个时候就可以使用 constexpr 表达式

```c++
int get_five() { return 5; }
int some_value[get_five() + 7]; // 创建包含12个整数的数组. C++03中非法，因为get_five() + 7不是常量表达式
```

C++11引入了关键字constexpr，允许编程者保证函数或对象的构造函数是编译时常量。上述代码可以改写为

```c++
constexpr int get_five(size_t i) { return i; }
int some_value[get_five(2) + 7];        	 //C++11
```



#### sizeof关键字

12.std::string s 和 std::string t = "HELLO, WORLD", sizeof(s) 和 sizeof(t) 分别是多少？

**答：**sizeof是C语言中的一个关键字（也是运算符），不是函数；其作用是以字节形式给出其操作数的的**存储大小**；操作数可以是一个表达式或者类型名，**操作数的存储大小由操作数的类型决定**

sizeof运算符（运算符也叫操作符）用于计算某种类型的对象在内存中所占的字节数；运算结果为类型名所指定的类型或者表达式的结果类型所占的字节数     （郑莉P32）

而string类型所占空间的大小不同编译器给出的结果都不同，我所用的是g++7.5.0版本，s 和 t 都是 string 类型，占32个字节；所以输出结果都是32

sizeof并不真实计算其运算对象的值

```c++
Test test, *p;
sizeof (*p);            
//在sizeof运算中解引用一个无效指针依然是一个安全的行为，因为实际指针并没有被真正调用，sizeof不需要真的解引用指针也能知道它所指向的对象类型
//这种操作和 decltype()很像
```

sizeof 后面如果是一个解引用指针，则返回结果为该指针所指向的类型大小

附：使用sizeof计算没有成员的结构体占用的空间是多少字节？  （参见声网2020校招T22）

**答：**空结构体或空类也可以被实例化，但是空结构体和空类的实例中不包含任何信息，理论上对其求sizeof应该为0，但是当我们声明该类型的实例时，它必须在内存中占用一定的空间，否则我们无法使用这个实例；为了达到这个目的，编译器往往会给空类或者空结构体隐含的分配一个字节的空间，这样空类或空结构体在实例化后在内存中就得到了一个独一无二的地址，所以空类所占的大小为1字节



#### volatile关键字

直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制；例如，程序可能包含一个由系统时钟定时更新的变量；当对象的值可能在程序的控制或者检测之外被改变时，应该将该对象声明为 volatile；关键字 volatile 就是告诉编译器不应对这样的对象进行优化   （《C++Primer》P757）

volatile 是一种类型修饰符，用它声明的类型变量表示是可以被某些编译器未知的元素修改，比如：操作系统，硬件或者线程等；遇到这个关键字声明的变量，编译器对该变量的代码就不再进行优化，从而可提供特殊地址的稳定访问；见CSDN博客(C++分栏) 

当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据

```c++
volatile int i = 10;
int a = i;
int b = i;
```

volitate指出 i 是随时可能发生变化的，每次使用它的时候必须从 i 的地址中读取，因此编译器生成的汇编代码会重新读取数据放在b中；而优化的做法是由于编译器发现两次从 i 读取的数据之间的代码没有对 i 进行任何操作，它自动会把上次读取的数据放在b中，而不是重新从 i 里面读取，这样一来如果 i 是一个寄存器变量或者表示一个端口数据就容易出错

所以说volatile可以保证对特殊地址的稳定访问

volatile作用：告诉编译器不要把变量优化到寄存器中。在开发多线程的程序时，如果这些线程共享一些全局变量，这些全局变量最好使用valotile修饰。这样可以避免因为编译器优化而引起的错误

volatile修饰的变量，每次读取必须去内存中读取数据，而不相信寄存器或者cache中的数据准确性

注：volatile不能取代锁来解决多线程竞争问题

volatile是用来修饰一些因为程序不可控因素导致变化的变量，比如访问底层硬件设备的变量，以提醒编译器不要对该变量的访问擅自进行优化，但是volatile并不能保证操作的原子性，在读取、写入变量的过程中仍然可能被其他线程打断导致意外结果发生，所以线程之间竞争问题的解决还是需要锁

问：const 和 volatile可以一起使用吗？

**答：**const 和 volatile可以一起使用，作用就相当于告诉编译器：该变量在本程序段不能做修改，但是在另一个程序段可能会被修改，告诉编译器对该变量不要做优化；见CSDN博客(C++分栏)



#### public 和 protected 以及 priavte

类内的公有成员是这个类提供给外界的使用接口，用来给外界操作类对象

保护成员则主要用于在类的继承关系中，用于提供给派生类使用；保护成员在类外是无法被访问的，如果没有继承关系，则保护成员和私有成员的属性完全一样

私有成员只能被本类的成员访问，来自类外部的任何访问都是非法的，也不能被派生类访问；私有成员完全屏蔽在类中，保护了数据的安全性

对继承而言：

首先明确一点，无法是什么继承方式 (公有继承，私有继承，保护继承) 都是修饰的基类成员继承过来后在派生类的访问属性

也就是说只要基类成员在类内属性是public或者protected，无论是私有继承还是公有继承还是保护继承，我派生类都能够访问到；但是基类的私有成员访问不到

公有继承：基类的公有成员和保护成员在派生类的访问属性不变

保护继承：基类的公有成员和保护成员在派生类的访问属性变成 protected

私有继承：基类的所有成员在派生类的访问属性全部变成 private



#### extern关键字

**答：**两个作用

1.用来声明一个外部变量 	 2.用来声明一个外部函数     		注：外部变量和外部函数也叫全局变量和全局函数

说白了就是声明一个在其他文件中定义好的变量，该文件想要引用其他文件定义好的全局变量或者全局函数时，要提前用extern关键字做声明

```c++
file.c     //文件1
int A = 10;
void fun(){ std::cout << "hi" << std::endl; }

main.c    //文件2
extern int A;               //声明一个外部变量
extern void print();        //声明一个外部函数

std::cout << A << std::endl;    //声明后直接用就可以，不需要include包含file1.c的文件,链接时将这两个文件链接成一个可执行文件即可
fun();
```

附：定义和声明的区别

把建立存储空间的声明称为定义，而把不需要建立存储空间的声明称为声明；前者称为定义性声明 (简称定义)，后者称为引用性声明



37.C++调动C库函数需要注意什么？	17.C++中怎么使用C

**答：**使用 extern "C"，其作用是告诉编译器括号里面的内容是按照C语言的文件格式编译的，需要链接的话按照C的命名规则去查找

```c++
extern "C" {
    #include "f.h"
}
```

现在我们有一个C库文件，它的头文件是 f.h，产生的lib文件的 f.lib，那么我们如果想要在C++中使用这个头文件，需要像上面那样写

C++ 程序有时候需要调用其他语言编写的函数，最常见的就是调用 C 语言编写的函数；像所有其他名字一样，C++ 其他语言中的函数名字也必须在 C++ 中进行声明，并且该声明必须指定返回类型和形参列表；对其他语言编写的函数来说，编译器检查其调用方式与处理 C++ 函数的方式相同，但是生成的代码有所区别，**C++使用链接指示指出任意非C++使用的语言**

注：要想把C++代码和其他语言（包括C语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器兼容　　　(《C++Primer》P758)

例：

```c
#test.c 文件
void fun() {
    printf("hello world");
}
```

```c++
#main.cc 文件
extern void fun();		//错误:这属于C++里面调用C语言写的文件，必须使用链接指示命令
extern "C" {
    extern void fun();	//正确
}

int main() {
    fun();	
    return 0;
}
```

























