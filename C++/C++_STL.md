## STL组件

#### STL六大组件

**答：**STL的价值在于两方面：就底层而言，STL带给我们一套极具实用价值的零部件以及一个整合的组织；除此之外，STL还带给我们一个高层次、以泛型思维为基础的、系统化的“软件组织分类学”；六大组件分别为：

1.容器(containers)：各种数据结构，如 vector, list, deque, set, map 用于存放数据，从实现角度来看，STL容器是一种 class template

容器按类型来分有顺序容器，关联容器和无序容器

顺序容器包括 vecotr，双端队列，和 list，它们在逻辑上可看作是一个长度可扩展的数组，容器中的元素都按线性排列

关联容器是指它的每个元素都有一个key，容器中元素的顺序不是由程序员决定，而是需要按照key的取值排列；关联容器的底层是借助红黑树实现

关联容器又可分为简单关联容器，如：set, multiset；二元关联容器，如 map, multimap

无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数来对key和value值建立一组映射关系；在关键字的类型没有明显的有序关系的情况下，无序容器效果最佳；因为在某些应用中，维护元素有序这个代价会比较高，此时应用无序容器最佳；

无序容器有 unordered_map, unordered_set，unordered_multimap, unordered_multiset



2.算法(algorithm)：各种常用的算法，如 sort, search, copy, erase... 从实现角度来看，STL算法是一种 function template



3.迭代器(iterators)：扮演容器与算法之间的胶合剂，是所谓的"泛型指针"；从实现角度来看，迭代器是一种将 operator *, operator->, operator++, operator--等指针相关操作赋予重载的 class template

迭代器是一种抽象的设计概念，在设计模式一书中的定义为：提供一种方法，使之能够依序的访问某个聚合物（容器）中所含的各个元素，而又不需要暴露该聚合物中的内部实现细节；也就是说迭代器能够访问容器内部实现，而不需要管容器中是怎么实现的



4.仿函数(functions)：行为类似函数，可以作为算法的某种策略；从实现角度来看，仿函数是一种重载了 operator( ) 的 class 或 class template



5.适配器 (adapters) 也叫配接器：一种用来修饰容器或仿函数或迭代器接口的东西；例如 STL 提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器适配器，因为它们的底部完全借助deque，所有操作都是由底层的deque 供应



6.配置器 (allocator)：负责空间配置与管理，从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template

C++的内存配置基本操作是 ::operator new( )，内存释放基本操作是 ::operator delete( )；这两个全局函数相当于C的malloc( )和free( )函数

考虑到小型区块可能造成的内存碎片问题，STL设计了双层级配置器，第一级配置器直接使用 malloc 和 free ，第二级配置器则采用内存池机制；当配置区的区块超过 128Byte 时，视之为 "足够大"，便调用第一级配置器；当配置区块小于 128Byte 时，便采用内存池（memory pool）的方式

内存池的分配方式：每次配置一大块内存，并维护对应的链表（链表节点指向为分配的内存地址），下次若再有相同大小的内存需求，则直接从链表中拔出（从链表上摘下一个节点），释放内存也由配置器回收到链表中（链表增加一个节点）

如果内存池剩余内存不够，则会自动利用malloc函数从堆中配置内存，新的空间大小为需求量的两倍，再加上一个随着配置次数增加越来越大的附加量    《源码剖析》P68



六大组件之间的关系：容器 (container) 通过配置器 (allocator) 取得数据存储的空间；算法 (algorithm)通过迭代器 (iterators) 存取容器内容；仿函数可以协助算法完成不同的策略变化，适配器可以修饰或者套接容器，仿函数或者迭代器



#### 容器

##### 1.vector扩容机制？2.vector在begin的位置插入一个元素后迭代器为什么会失效？  (郑莉P416)

**答：**向量容器一般实现为一个动态分配的数组，当插入一个元素而提前没有使用 reserve 函数为 vector 预留足够大的容量时，这时数组的空间不够，向量容器对象就会自动 new 分配一块更大的空间，使用赋值运算符"="将原有数据分别复制到新的空间中，并将原有空间释放；这就是向量容器的动态扩展容器空间的功能

解释完向量容器的特征，再来回答为什么在 vector 的 begin 位置插入一个元素后迭代器会失效：

1.如果事先没有通过reserve函数确保vector有足够的容量，向量没有多余的一个容量来容纳该元素，这时插入操作会引起向量容量的扩展，这时就会导致空间被重新分配，元素的内存地址发生了改变，自然迭代器就会失效；

2.如果向量容器有多余的容量来容纳插入的这一个元素，这时由于插入元素的位置在首位，同样迭代器会失效，因为原有元素的位置都被移动了

3.如果容器空间足够，且是在尾部添加元素，则不会导致迭代器失效



##### 3.vector为什么是以2倍扩容

**答：**假设存在n个元素，扩容的因子为m

1.如果不按照倍数扩容，而是按照固定数目扩容，则将这n个元素 push_back 的总时间复杂度为 O(n^2)
$$
\sum_{i=1}^{n/m}{mi} = m + 2m + 3m + ... + (n/m)m = n/2(1+n/m)
$$
均摊到n个元素的时间复杂度为 O(n)

2.如果是按照倍数扩容，则将这 n 个元素push_back的总时间复杂度为
$$
\sum_{i=1}^{\log_mn}{m^i} = m + m^2 + m^3 +...+ m^(log_mn) = m(n-1)/(m-1)
$$
n很大时，均摊到每个元素上的时间复杂度为 O(1)

显然增长的倍数不能比1小，也不能比2大，因为如果>=2，下一次申请的内存会大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以倍增因子在 (1,2) 之间

所以综合考虑vector扩容的倍增因子设置成1.5更加合理，而VS下是1.5倍扩容，GCC下是两倍扩容

```Ba
1,2,4,8,16 ...
2>1, 4>1+2, 8>1+2+4
```

理想情况下是第N次扩容分配内存的时候能复用前N-1次释放的内存，但根据上面的例子，两倍扩容显然无法做到，1.5倍扩容可以做到

如果扩容倍率太低，继续插入元素的话会出现频繁扩容的现象，效率降低；如果倍率太高，又会造成空间浪费，所以我想2倍或1.5倍是一个折中的考虑，兼顾了效率与空间利用率



##### 4.vector 的 push_back 和 emplace_back 有什么区别？

**答：**比如如下类：

```C++
class stu_info {
private:
    string name;
public:
    stu_info(const char *str) {
        this->name = str;
        cout << "构造函数" << this->name << endl;
    }
    stu_info(const stu_info &s) {
        this->name = s.name;
        std::cout << "拷贝构造" << std::endl;
    }
    ~stu_info() {
        cout << "析构函数" << this->name << endl;
    }
};
vector<stu_info> nums;
```

在使用 push_back 时，必须要传入一个对象 (不论是已经实例化好的对象还是一个临时对象)，之后将该对象利用拷贝构造函数拷贝到容器管理的内存空间中

如果传入的是临时对象，则会存在一次构造和拷贝构造操作

```C++
nums.push_back(stu_info("Bob"));            //这会先构造一个临时对象，然后将这个临时对象利用拷贝构造再构造出一个临时对象将其压入容器中；
nums.push_back(demo);                       //这会调用一次拷贝构造生成一个临时对象压入容器中
nums.emplace_back("Bob");                      //只会调用一次构造函数
```

而在调用 emplace_back 时，会在容器管理的内存空间中直接创建对象，只会调用一次构造函数

由于 emplace_back 在容器中直接构造元素，因此传给 emplace 函数 (包括emplace, emplace_front, emplace_back) 的参数必须与元素类型的构造函数相匹配

因此 emplace_back 函数的作用就是减少对象的拷贝和构造次数，是C++11新特性，主要适用于临时对象的赋值



附：vector和list的区别以及具体的应用场景？如果我想实现一个栈，用哪个比较好？

**答：**使用vector比较好，因为 list 是利用的不连续的内存空间，而vector利用的是连续的内存空间；如果使用list那么频繁向栈中压入或者弹出元素会导致链表节点的反复增加和删除，也就会涉及到内存的反复申请和释放，效率比较低；



附：为什么vector扩容使用的是拷贝构造而不是移动构造？

**答：**因为如果采用移动构造，因为对象移动后会改变源对象的值；如果使用移动构造函数的过程中，在移动了部分元素而不是全部元素之后抛出了一个异常，就会出现问题，因为原有空间的元素已经被改变了， 但是新空间中未构造的元素可能尚不存在

所以如果vector扩容采用的是移动构造而不是拷贝构造，需要把移动构造设置为不抛出异常



##### 4.vector中的resize( ) 和 reserve( )的区别

**答：**resize( )是设置大小(size)；reserve( )是设置容量(capacity)

size( )是指分配容器的内存大小，而capacity( )只是设置的容器的容量，并没有真正分配内存

打个比方：

```bash
正在建造的一辆公交车，车里面可以放置40个座椅，这个40指的是它的容量，但并不是说它里面就有40个座椅，只能说明这部车内部空间大小可以放得下40张座椅而已; 而车里面安装了40个座椅，这个时候车里面才真正有了40个座椅，这是指大小
```

总之：capacity 指容器在分配新的存储空间之前能存储的元素总数；  size 指当前容器存储的元素个数，容量(capacity)一定大于等于大小 (size)

所以resize和reserve区别如下：

1.reserve 表示容器预留空间，但不是真正的创建对象，需要通过 insert( ) 或者 push_back( ) 等创建对象；而resize( )既分配了空间也创建了对象

2.reserve只修改capacity大小，不修改size大小；resize既修改capacity大小，也修改size大小

3.resize(n, num )带两个参数，n表示容器大小，num表示设定的初始值；当只有resize(n)时默认初始值为0

reserve(n)带一个参数，n表示预留的容器空间大小



##### 5.STL中的stack的pop( ) 以及vector中的pop_back( ) 函数为什么不返回值，而返回void？

**答：**当栈顶元素弹出后，我们不得不返回这个元素的值而不能返回引用，因为这个元素已经从栈中剔除了，如果返回值就必然会发生一次对象的实例化，这样效率不高；

而top( ) 函数虽然不弹出元素，但是可以返回引用，也就不必发生实例化



附：所有容器都有 begin 和 end 成员，以及 rbegin 和 rend 成员

所以想取得容器最后一个元素可以使用 *mySet.rbegin( )；

注意 erase 函数只能传入一个正向迭代器，不能传入反向迭代器，不能传入 mySet.erase(mySet.rbegin( )); 

```C++
mySet.erase(mySet.rbegin());	//错误，erase 函数不接受反向迭代器
mySet.erase(--mySet.end());		//正确，删除容器最后一个元素
```



##### 43.知道STL吗，讲一讲STL中的list

41.向量(vector)和双端队列(deque)以及列表(list)和映射(map)的区别以及应用场景？ (郑莉P416)

**答：**1.vector的实现是动态数组；如果需要实现执行大量的随机访问操作，而且当扩展容器时只需向容器尾部加入新的元素，就应当选择向量容器vector

2.deque的实现是分段数组，容器中的元素分段存放在一个个大小固定的数组中 (数组大小默认是512Byte)，随时可以增加一段新的空间并链接起来，因此 deque 还需要维护一个存放这些数组首地址的索引数组；如果不需要对已有元素进行移动，而是只需要在两端执行插入和删除操作，就应当选择双端队列deque

3.list的实现是双向链表；由链表的性质知如果不需要对容器进行随机访问，只需在任意位置插入或者删除元素，就应当选择列表容器list  

4.set和map的底层实现是红黑树；如果需要频繁根据键值来查找对应的元素，则应当选择映射容器map

5.unordered_set 和 unordered_map 的底层实现是哈希表

附：无序容器在存储上组织为一组桶，每个桶保存零个或者多个元素；无序容器使用一个哈希函数将元素映射到桶中；为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶；容器将具有一个特定哈希值的所有元素保存到相同的桶中；如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中；因此无序容器的性能依赖于哈希函数的质量和桶的大小 P395

哈希函数：将给定类型的值映射到整形 (size_t) 值的函数；相等的值必须映射到相同的整数；不相等的值应该尽可能映射到不同整数     P397



6.set和map

注：set元素和map的键值都不可以修改，因为其会关系到在红黑树上的排列顺序，随意改变会破坏红黑树结构；不允许修改key值，但是可以直接将其删除

map 底层是红黑树，所以可以理解红黑树的每个节点存储的是pair，pair的第一个元素是 map 的 key 值，第二个元素是 value 值

unordered_map 的底层由哈希实现，哈希函数将key值哈希到hash table上存储对应的value值



#### 迭代器

3.STL有几种迭代器？

**答：**根据移动特性，迭代器被分成5类

输入迭代器 (Input Iterator)：这种迭代器所指的对象，不允许外界改变；是只读的 (read only)，输入迭代器只允许顺序访问；istream_iterator就是输入迭代器

输出迭代器 (Output Iterator)：只允许写 (write only)，可以看作输入迭代器功能上的补集，只写而不读元素；ostream_iterator就是输出迭代器

前向迭代器 (Forward Iterator)：可以读写元素，这类迭代器只能在序列中的某一个方向移动，前向迭代器支持所有输入输出迭代器的所有操作；允许 "写入型" 算法 (例如 insert( ), replace( )) 在此种迭代器所形成的区间上进行读写操作

双向迭代器 (Bidirectional Iterator)：可正向/反向读写序列中的元素，双向迭代器支持所有前向迭代器的操作；算法 reverse 要求双向迭代器；可双向移动，某些算法需要逆向走访某个迭代器区间内的元素

随机访问迭代器 (Random Access Iterator)：前四种迭代器都只提供一部分指针算术运算能力 (**前三种支持 operator++，第四种支持operator--**)，而随机访问迭代器涵盖所有指针算术运算，如p+n, p-n, p[n], p1-p2, p1<p2；提供在常量时间内访问序列中任意元素的能力，支持双向迭代器的所有功能



附：STL每种容器对应的迭代器

**答：**vector 和 deque 是随机访问迭代器		list、(multi) set/map 是双向迭代器

unordered_set/map 是前向迭代器				stack、queue 和 priority_queue 不是容器，是配接器



#### 仿函数

21.仿函数了解吗？

**答：**仿函数的主要功能是为了搭配STL算法来使用，单独使用仿函数的情况比较少

仿函数(functions)在C++标准中采用的名称是函数对象；仿函数主要用在STL中的算法中，**仿函数的本质就是重载了operator()的一个类**，创建一个行为类似函数的对象

对于重载了"( )"操作符的类，可以实现类似函数调用的过程，我们将这种类对象称为函数对象或者仿函数，实际上仿函数对象仅仅占用1字节，因为内部没有数据成员，仅仅是重载了一个方法而已；实际上可以通过传递函数指针实现类似的功能，但是为了和STL内部配合使用，提供了仿函数的特性

1).仿函数是一个类，不是函数

2).仿函数重载了"( )", 使得可以类似调用函数那样调用实例；所以大小堆的调用是greater\<int>( ), 就是类似调用函数的，实际上是一个叫 greater 的模板类，输入的参数类型是int, ( ) 是这个模板类的一个函数 (匿名函数)



sort函数的第三个参数是一个谓词 （<C++Primer>P344）

谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，标准库中的算法所使用的谓词只有两类：一元谓词 ( 只接收单一参数 ) 和二元谓词 (可接收两个参数)

接收谓词参数的算法对输入序列中的元素调用谓词，因此元素类型必须能转换成谓词的参数类型

```C++
std::vector<std::pair<int,int>> nums;
//元素对象为pair会默认先按照first升序排列，再按照second升序排列
```

如：sort 算法默认是使用元素类型的 '<' 运算符；接收一个二元谓词的sort函数的版本实际上是用这个谓词代替'<' 运算符来比较元素

附：注意 sort 和 priority_queue 的第三个参数可以传入一个仿函数，用来定义元素的排列顺序； 另外sort的第三个参数还可以传入一个bool函数，或者直接用 lambda 表达式

```C++
sort(vec.begin(), vec.end(), std::less<int>());      //从小到大排序，sort的默认排序规则
sort(vec.begin(), vec.end(), std::greater<int>());   //从大到小排序
sort(vec.rebgin(), vec.rend());    //从大到小排序，使用逆向迭代器

priority_queue<int, std::vector<int>, less<int>> pq;    //从大到小排序，默认的排序规则,注意这里不能写成less<int>(),这会调用less的默认构造函数
priority_queue<int, std::vector<int>, std::greater<int>> pq;    //从小到大排序
```

上述的差别主要在于优先队列的内部默认实现方式是最大堆，push对应的底层函数是push_heap( )，每次添加元素入堆时，在默认情况下添加进去的数据作为较小值入堆

top( ) 函数是取堆顶元素

如果需要自定义排序方式，需要重写仿函数，注意仿函数不是函数，Cm p应该是一个类或者struct  (见C++(String和STL库))



#### 算法

所有的 STL 算法都是作用在由迭代器 [first, last) (前闭后开区间，或称为左涵盖区间) 所标识的区间上

算法分成两种：

质变算法：会改变所操作的内容；如：sort, copy, swap, replace, erase, remove

非质变算法：不改变其操作内容；如：find, count, min, max, search, lower_bound, upper_bound

除去数值类算法，如 : accumulate( ) 在头文件\<numeric>中，其他的所有STL算法声明都在头文件 \<algorithm>中

附：用一行代码删去vector中的偶数元素

```C++
remove_if函数的使用
std::vector<int> nums = {0,1,2,3,4,5,6,7,8,9};
remove_if(nums.begin(), nums.end(), [](int &x){ return !(x&1); });        
//千万注意，这里remove_if不删除偶数元素,只是将奇数元素全放到数组前面
//这里的if条件是元素是偶数就满足,所以会将奇数全部提到数组前面来, remove_if返回结果为满足条件的最后一个元素的下一个迭代器

for_each(nums.begin(), num.end(), [](int &x) { std::cout << x << " "; });    
//打印结果为 1,3,5,7,9,5,6,7,8,9    可见remove_if只是将符合条件的元素提到了数组前面

nums.erase(remove_if(nums.begin(), nums.end(), [](int &x){ return !(x&1); }), num.end()); //只保留奇数元素,打印结果为 1,3,5,7,9
```

注：remove_if 不能用于关联式容器，因为元素会发生变动，这样会影响关联式容器上的元素的排列规则，比如不能用于map，因为map中的元素组织是依赖红黑树自动进行的，不可随意调换元素位置

附：map中删去偶数元素

```C++
std::map<int,int> hash = {{1,1}, {2,2}, {3,3}, {4,4}, {5,5}};
for(auto it = hash.begin(); it != hash.end();) {
    if(!(it->second & 1)) it = hash.erase(it);
    else it++;
}

//map的第一个元素关系到元素搭配红黑树上的排序规则,不允许修改，所以只能是const类型
for(std::pair<const int, int> &item : hash) {
    std::cout << item.first << " " << item.second << std::endl;
}
```



STL线程安全问题

STL容器不是线程安全的；对于vector，即使写方(生产者)是单线程写入，但是并发读的时候，由于潜在的内存重新申请和对象复制问题，会导致读方(消费者)的迭代器失效。实际表现也就是招致了core dump。另外一种情况，如果是多个写方，并发的 push_back()，也会导致core dump

解法一：加锁是一种解决方案，但是加 std::mutex 互斥锁确实性能较差；对于读多写少的场景可以用读写锁（也叫共享独占锁）来缓解，C++17引入了std::shared_mutex

解法二：更多的时候，其实可以通过固定 vector 的大小，避免动态扩容(无push_back)来做到 lock-free(无锁)

即在开始并发读写之前(比如初始化)的时候，给 vector 设置好大小，注意是使用 resize，不是reserve！

可能大家平时用 reserve() 比较多，顾名思义，reserve 就是预留内存。为的是避免内存重新申请以及容器内对象的拷贝。说白了，reserve()是给push_back()准备的！

而 resize 除了预留内存以外，还会调用容器元素的构造函数，不仅分配了N个对象的内存，还会构造N个对象。从这个层面上来说，resize()在时间效率上是比 reserve()低的。但是在多线程的场景下，用 resize 再合适不过

你可以resize好N个对象，多线程不管是读还是写，都是通过容器的下标访问【operator[]】来访问元素，不要push_back新元素。所谓的『写操作』在这里不是插入新元素，而是修改旧元素



string 也不是线程安全的

string 会有自己的扩容机制，如果当前线程插入新的元素而导致存储字符串的空间扩容后，内存地址会被重新分配，而其他线程里面可能还是之前的未重新分配内存之前的地址，那这种操作就是不安全的

