区分指针和指针变量：指针就是地址，指针变量是用来存放地址的变量；所以指针变量的值就是地址       

如：int *p, a;  p = &a;

p是指向 int 型类型的**指针变量**，将p指向a, 则指针变量p里面存放的就是a的地址

所以"定义一个指针" 这些说法是错的，地址怎么能定义，只能定义一个指针变量来存放地址



函数不要返回局部对象的指针或者引用

如果返回局部对象的引用， 则当函数调用结束时临时对象占用的空间也就随之被释放了，所以函数返回的是未定义的值

如果返回局部对象的指针，则当函数调用结束时局部对象被释放，指针便会指向一个不存在的对象



#### 指针和引用

1.引用和指针有什么区别？

**答：**引用可以认为是变量的一个别名；对引用的操作与对变量直接操作效果完全相同 （郑莉P79）

1.针对函数调用，引用的实参和形参是同一地址，而指针则需要分配内存；也就是指针需要占用内存空间，而引用不用，因为声明一个引用不是新定义了一个变量，它只是表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占用内存单元，系统也不会给引用分配存储单元

2.引用一旦声明就必须同时对其进行初始化，使其指向一个已经存在的对象；而指针可以指向为空；

3.引用初始化后就不能再指向其他对象；而指针则可以被重新赋值以指向其他变量

附：变量的访问方式有两种，一种是直接通过变量名访问，称为直接访问；另一种是通过变量的地址来访问，即用指针来进行访问，也称为间接访问；

对上述第二项的解释：

```C++
int num1 = 6, num2 = 10;
int &a = num1;   //这表示将引用指向了对象num1
a = num2;    	 //这不叫将引用a指向对象num2，这是对引用赋值，由于引用是别名，所以这里num1和a的值都是10
```

附：常引用的作用？

**答：**常引用就是在之前加上const对引用进行限制，使得该引用在函数中不能进行改变 ( 但可以改变原变量的值 )，比如：

```C++
int a = 3;
const int &b = a;
b = 2;				//错误，常引用的值不能修改
a = 2;				//正确，可以修改原变量的值
```



3.说一下指针和引用，函数传参使用哪个比较好？为什么不能用另一个？

**答：**指针和引用的定义见上面；

函数传参用引用比较好；如果使用指针进行函数传参，则在主调函数中需要使用"&"操作符传递参数（在主调函数中需要取地址），在被调函数中需要使用"*"操作符来访问数据（在被调函数中需要解引用）；

但是如果用引用的话只需要在被调函数中使用"&"操作符就可以了，这种参数传递使用引用比指针更加简洁，安全，而且还不容易出错；

补充：以下情况引用无法替代指针，引用只有在参数传递时比使用指针好     （郑莉P242）

1.如果一个指针所指向的对象需要利用分支语句来确定，或者需要在中途改变其所指向的对象，则不能使用引用代替，因为引用只能在初始化时指定被引用的对象

2.有时一个指针是空指针，比如把指针作为函数的参数类型或者返回类型时，有时需要使用空指针，这时引用不能代替

3.使用函数指针的情形，没有函数引用，所以引用不能代替

4.用new动态创建的对象或者数组，需要指针来存储其地址

5.像其他数据结构，比如链表、树等这类数据结构需要指针传递大批量数据时，也不能使用引用



11.讲讲深复制和浅复制(也叫深拷贝和浅拷贝)

**答：**1.在未定义显示复制构造函数的情况下，系统会调用默认的复制构造函数--即浅复制，它能完成成员的一一复制；当类的数据成员中没有指针时，浅复制是可行的；但当数据成员有指针时，如果采用浅复制，则两个对象的两个指针指向同一个地址，当对象释放时就会调用两次析构函数释放同一块内存，从而导致指针悬挂现象；所以此时必须采用深复制

2.浅复制和深复制的区别就在于深复制会在堆中额外申请空间来存储数据，从而也就解决了指针悬挂的问题；简而言之，当类的数据成员中有指针变量时，必须要用深复制

```C++
class A {
public:
    A() : size(0), data(nullptr) {}
    A(int n) : size(n), data(new int[size]) {}
    ~A() { delete data; }        //delete一个空指针也是可以的

    A(const A &demo) {
        size = demo.size();
        data = new int[size];
    }            

    A& operator=(const A &demo) {    //附：赋值运算符也需要深复制
        size = demo.size;
        data = new int[size];        
    }
    
private:
    int size;
    int *data;
};

A a(1);
A b(a), c = a; //如果没有显示定义拷贝构造函数或者重载复制运算符，该写法和下面这个写法是错误的
b = c;        
```

对同一块内存释放两次的结果是未定的，**可能导致内存泄露或者程序崩溃**



7.如何初始化一个指针数组？

**答：**指针数组是指数组中的每一个元素都存放一个地址；由于指针数组中的每个元素都是一个指针，所以将指针数组初始化也就是将指针数组中的每个元素都初始化，即每个元素都指向一个地址即可；如：

```C++
int *p[4];
int a = 1, b = 2, c = 3;
int *p[3] = {&a, &b, &c};		// 使用变量来初始化指针数组，即数组中的每个元素存放的是变量的地址
```



#### 内存分区以及内存对齐和内存泄露

4.内存分为哪些区？

**答：**内存中供用户使用的空间主要分为：程序区 ( 分为常量存储区和程序代码区 )、静态存储区和动态存储区 ( 动态存储区也叫栈区 )

常量存储区里面存放的都是常量，不允许修改 ( 当然也可以通过非正当手段修改 )，比如常量字符串就是存放在这里，程序结束后由系统释放；   程序代码区是存放函数的二进制代码

静态存储区存放的是全局变量和静态局部变量；已初始化的静态局部变量和全局变量存储在 .data段，未初始化的静态局部变量和全局变量存放在 .bss段

除去上面的三个区域，C语言还允许建立内存动态分配区域（也叫堆区），以存放一些临时数据，这些数据的存储空间是需要时随时开辟，不需要时随时释放；new 和 malloc 函数申请的内存空间都是在堆区

附：C++中已初始化的全局变量在编译时保存在 .data 段中，而没有被初始化的全局变量保存在 .bss 段中；这样保存的理由是在 .data 段的变量在编译生成的文件中需要分配空间存储变量值，而没有初始化的全局变量（或初始化为0的静态变量、全局变量）其默认值为都是0，没必要将这些值均为0的变量存储在 .data段，而采用 .bss 段只是给未初始化的全局变量和静态局部变量预留位置（就是为这些变量占个位）；.bss 段并不会存储这些变量的值，但是程序执行时这些变量会占用内存空间，所以可执行文件必须记录 .bss段中变量所占空间的大小



25.简单讲一下堆和栈 ( 从调用和内存分布两方面回答 )

**答：**

1.申请方式不同：栈由系统自动分配，堆是由程序员申请和释放的

2.申请大小限制不同：栈顶和栈底都是之前预设好的，栈是向低地址扩展，大小固定，可以通过 ulimit -a 查看；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整

3.申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员自己分配，速度慢，而且会有碎片；无论是在32位环境还是64位环境下，**栈空间默认为8M**，**堆空间一般是 不到2G**



附：栈和堆的内存管理机制？

**答：**对于堆：系统有一个记录空闲地址的链表，当系统收到程序申请内存时，遍历该链表，寻找第一个大于申请空间的节点，删除空闲节点链表中的该节点，并将该节点空间分配给程序 ( 大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本次申请的内存空间，另外系统会将剩余的部分重新放入到空闲链表中)   

对于栈：只要栈的剩余空间大于所申请的空间，系统为程序提供内存，否则报异常提示栈溢出

堆是不连续的内存区域 (因为系统是用链表来存储堆的空闲内存地址，自然是不连续的)，堆大小受限于计算机系统中有效的虚拟内存，所以堆的空间比较灵活，比较大；栈是一块连续的内存区域，大小是操作系统预先设定好的



附：什么时候用栈，什么时候用堆？

**答：**

1.如果是少量数据需要频繁的操作，那么在程序中使用栈会比较好；而如果需要分配大量的内存空间，则推荐使用堆内存；

2.如果想让资源的生命周期超过对应变量的作用域，用堆分配，因为堆中的内存需要程序员手动释放，而栈中的内存当变量离开其作用域就自动被回收了



附：进程几个堆几个栈，线程几个堆几个栈？

**答：**进程是资源分配的基本单位，线程是最小的执行单位，一个进程只有一个堆，但是栈的个数是线程栈的个数之和；线程独占栈，但是共享堆



附：数据结构中的栈和堆的区别？

**答：**

1.栈本质是线性表，是限定仅在表尾进行插入和删除操作的线性表；栈是先进后出

2.堆是完全二叉树，而且具有以下性质

1).每个节点的值都大于等于其左右孩子节点的值，称为大顶堆

2).每个节点的值都小于等于其左右孩子节点的值，称为小顶堆



附：数组和链表的区别

**答：**

1.数组静态分配内存，链表动态分配内存

2.数组在内存中占用连续的存储单元，而链表的存储单元不连续

3.数组元素在栈区，链表元素在堆区

4.数组利用下标来定位，查找的时间复杂度为O(1)；而链表的查找时间复杂度为O(n)

5.数组插入或删除的时间复杂度为O(n)；而链表插入或者删除的时间复杂度为O(1)



40.描述内存分配方式以及它们的区别？

**答：**三种分配方式

1.从静态存储区分配：所占用的内存大小在程序编译时就计算好，这块内存在程序的整个运行期间都存在；   例如全局变量和static变量 (static变量就包括了静态局部变量和静态全局变量)

2.从栈上分配：在执行函数时，函数内局部变量的存储单元都在栈上创建，函数结束时这些存储单元自动被释放；   局部变量和函数参数都是存放在栈中

3.从堆上分配(也称动态内存分配)：程序在运行的时候用malloc或new申请任意的内存，程序员自己负责在何时释放该内存；动态内存的生存期完全由程序员决定

附：书上说的在编译期间分配内存不是真的在编译期间分配内存，而是计算所占用的内存大小；此时只是根据声明时的类型先进行占位，到以后程序运行时分配内存才会开始

所谓在编译期间分配空间指的是静态分配空间（相对于用new动态申请空间）；如全局变量或静态变量，它们所需要的空间大小可以明确计算出来，并且不会再改变，因此它们可以直接存放在可执行文件的特定的字节里（而且包含初始化的值），程序运行时也是直接将这个字节加载到特定的段中，不必在程序运行期间用额外的代码来产生这些变量



9.什么是野指针和悬空指针？（如果不细分，悬空指针也是属于野指针，如果面试官没有细问，就只是问野指针，需要连带悬空指针一起回答出来）

**答：**野指针概念：指针变量指向了一块随机的空间，不受程序控制

野指针产生的原因：指针变量定义时未及时初始化

悬空指针产生的原因：指针变量指向的对象被释放后没有将指针指向为空；

```C++
int *p1;   //p1就是一个野指针,指针定义后未及时初始化
/*修改为*/ int *p1 = nullptr;

int *p2 = new int(5);
delete p2;				//指针指向对象释放后没有及时将其置为空
/*修改为*/ p2 = nullptr; 
```

野指针危害总结：

1.指向不可访问的一段地址，触发段错误

2.指向一个可用的，但是正在被使用的空间，如果在此时对这段空间解引用后，对其加以修改或者释放，但是这段空间正在被使用，这是非常危险的操作，程序会崩溃，数据也会可能被破坏

附：赋值给指针变量的值必须是地址常量 ( 比如数组名 ) 或者地址变量，不能是非0的整数；但是可以给指针赋值为0，表示该指针是一个空指针，不指向任何地址；如：

```C++
int *p;  p = 0;
//空指针更多的使用NULL来表示，如 int *p = NULL; 其中 NULL 是一个在很多头文件都有定义的宏，被定义为0
```



34.什么叫内存泄露？如何排查及解决？

**答：**用new分配的内存，必须用delete加以释放，否则会导致动态分配的内存无法回收，使得程序所占的内存越来越大，这就叫 “内存泄露”       （郑莉P219）

1)：造成内存泄露的原因是什么？

**答：**一般情况下造成内存泄露的主要原因是，由于程序设计的不合理，未对动态申请的堆空间进行回收，或者只在程序的部分出口对申请的内存空间进行回收，从而导致被某个程序弃用却不能被其他程序使用的内存越来越多

(1).可能是 new 后的内存使用完后忘记 delete 释放了

(2).如果在 new 和 delete 之间发生异常，其异常没有被捕获，则这块 new 出来的内存就永远没办法释放了（《Primer》P415）

2).内存泄漏带来的危害？

**答：**内存泄露会减少可用内存的数量从而降低计算机的性能；而且当所消耗的资源达到系统的上限时，程序自己会崩溃，严重者甚至会导致系统崩溃

3).Linux查看内存泄漏的命令？

**答：**Linux下可利用ps或者top命令查看程序的内存使用情况

4).内存泄露的检测办法？

**答：**1.使用检测工具，如 Valgrind工具里面有一个 memchek 功能可以检测

2.程序员需要记住申请的内存后面一定要释放， 比如可以定义一个变量，在申请内存的时候将该变量加1，释放内存的时候将该变量的值减去1，这样程序运行时可以观察这个变量的值大致来判断是否哪里忘了释放内存

3.使用智能指针，注：智能指针不是百分百就能防止内存泄露，例如 shared_ptr 可能存在互相引用导致形成环的情况，最后二者内存都释放不了



常见的内存问题一共七种

1.动态内存泄露；		2.资源泄露，比如文件指针不关闭；		3.动态内存越界；		4.数组内存越界；

5.动态内存double free；	6.使用野指针，即未初始化的指针；		7.释放野指针，即未初始化的指针



35.堆栈溢出的原因

**答：**1.没有垃圾回收机制； 2.层次太深的递归调用



#### 内存对齐

27.什么是内存对齐？为什么要对齐？

**答：**现在计算机中的内存空间都是按照字节划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但**实际情况是在访问特定类型的变量的时候经常在特定的内存地址访问**，这就需要各种数据类型按照一定的规则在空间上排列，而不是顺序的一个接着一个排列；这就是所谓的内存对齐

![](https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/Image17.png) 



结构体内存对齐三大原则

(1).结构体变量中的成员的偏移量必须是成员大小的整数倍   

(2).结构体大小必须是任一成员大小的整数倍，也即所有成员大小的公倍数

(3).如果程序中有 #pragma pack(n) 预编译指令，则所有成员对齐字节数取为 n 和成员所占内存大小的较小者

```C++
struct Test {
    char sex;
    int age;
    char name[10];
};
// 未指定对齐字节数则默认以4字节对齐, sizeof(Test) = 20
// char型占1字节，int型占4字节，这两个变量对齐所占字节数为8字节，加上下面数组的10字节，一共18字节
// 但是现在4字节内存对齐，所以总结果为20字节
```

指定内存对齐方式，内存对齐字节数必须为 2^(n)

方法一：使用 pack 命令

```C++
#pragma pack(n)
#pragma pack()
```

方法二：

```C++
struct Test {
    ...
}__attribute__((aligned(n)));
//让所作用的结构体以n字节对齐，如果结构体中有成员长度大于n,则按照最大成员长度来对齐

struct Test {
    ...
}__attribute((packed));
//取消结构体在编译过程中的优化对齐，按照实际字节数来进行对齐
```



#### 程序运行

1.在main函数之前和之后的代码可能是什么？

**答：**main函数之前主要是初始化系统相关资源

1.设置栈指针

2.初始化静态变量和全局变量，即 .data段的内容；将未初始化部分赋初值：数值型 short，int，long 等为0，bool型设置为false, 指针置为空，即 .bass段的内容

3.全局对象初始化，在main函数之前如果有全局对象，则执行初始化

4.将main函数的参数传递给argc，argv等传递给main函数，然后才开始真正运行main函数

main函数执行之后：

1.全局对象的析构函数会在main函数之后执行

2.main 函数之后可用 atexit 注册函数等待 main 函数结束后调用



22.C语言必须从main函数开始执行吗？main函数执行完后还可以执行其他语句吗？

**答：**C语言不一定要从main开始执行

C语言有一个"\_\_attribute\_\_"关键字，可以用来设置函数属性， 变量属性和类型属性；\_\_attribute\__ 前后都有两个下划线，并且后面会紧跟一对圆括号，括号里面是相应的 \__attribute__参数

语法为：\_\_attribute__( ( arrribute-list ) )

若函数被设定成 constructor 属性，则该函数会在main函数执行之前被自动的执行；若函数被设定为 destructor属性，则该函数会在main函数执行之后被自动执行

```C++
__attribute__((constructor)) void before_main() {
    printf("%s\n", "hi");
}
__atrribute__((destructor)) void after_main() {
    printf("%s\n", "world");
}

int main() {
    printf("%s\n", "main");
}

输出：
hi
main
world
```



如果想要在main函数结束之后执行一段代码既可以使用上面的 \__arrtibute__ 关键字，也可以使用atexit函数

atexit函数是用来注册程序正常终止时要被调用的函数，atexit( ) 函数的参数是一个函数指针，函数指针指向一个参数为void，返回值类型也为void的函数

函数原型为 int atexit( void( *fun(void) ) )

另外atexit( ) 注册的函数在入栈时的顺序与调用atexit( ) 的顺序相反，即先调用的后执行

```C++
void fun1() {
    printf("%s\n", "hi");
}
void fun2() {
    printf("%s\n", "world");
}

int main() {
    atexit(fun1);
    atexit(fun2);
    printf("%s\n", "main");
}

输出：
main
world
hi
```



2.程序由代码到运行的经历了哪几个过程

**答：**以 helloWorld 程序为例；  流程为四步：预处理 -> 编译 -> 汇编 -> 链接

1.预处理器所涉及的具体操作为：将头文件展开，宏替换，注释去掉，添加行号和文件名标识 (为了GDB调试)                                                      

2.编译器对源代码进行词法分析与语法分析，检查是否存在语法错误，以及代码优化也在这一步完成；将源文件生成汇编文件      

3.汇编器将上一步生成的汇编文件转变为机器可以识别的二进制文件 (机器码文件)                                           

4.链接器将 .o文件加上系统库中的文件一起链接成可执行文件 a.out；     链接所涉及的具体操作为：将函数库中相应的代码组合到目标文件中，该例具体为将 printf 函数目标文件组合到当前文件中

四步对应的命名分别为

```C++
gcc -E test.c -o test.i    .c->.i
gcc -S test.i -o test.s    .i->.s
gcc -c test.s -o test.o    .s->.o
gcc *.o -o                 .o->a.out
```

附：通常编译器会帮我们把预处理(预编译)，编译，汇编和链接的过程都做了

所以广义的编译指的是预处理，编译，汇编和链接这整个过程；狭义的编译指 \*.i 文件生成 *.o 文件的过程

附：gcc 和 g++ 编译器的区别

**答：**gcc 和 g++ 的区别主要是在对 cpp 文件的编译和链接过程中，因为cpp和c文件中库文件的命名方式不同，那为什么g++既可以编译C又可以编译C++呢，这时因为 g++ 在内部做了处理，默认编译 C++ 程序，但如果遇到 C 程序，它会直接调用 gcc 去编译；换句话说 gcc 用来编译c程序，而 g++ 编译 C++ 程序，但是如果有 C 程序 g++ 会调用 gcc 编译

附：汇编之后的文件为什么不可以直接执行？

**答：**需要链接静态库或者系统提供的库 ( 比如C语言的C库 )

比如 printf( ) 函数是由系统提供的，在链接的过程中就需要在C语言系统函数库中找到相应的代码并将其组合到目标文件中



24.静态链接和动态链接的优缺点？15.动态链接库和静态链接库的区别？

**答：**Linux下静态库后缀名为 (.a)，动态链接库后缀名为 (.so)

Windows下静态链接库后缀名为 (.a)，动态链接库后缀名为 (.dll)

之所以称为静态库，是因为在链接阶段会将汇编生成的目标文件.o与引用的库一起打包到可执行文件中，因此对应的链接方式称为静态链接

之所以称为动态库，是因为动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被动态加载进去

静态库的优点：1.发布的时候不需要提供对应的库； 2.加载的速度比较快

静态库缺点：1.库打包到应用程序中，导致可执行程序的体积很大；  2.库发生了改变就需要重新编译

动态库的优点：1.执行程序体积较小     2.动态库如果更新了不需要重新编译程序，只要函数接口不变

动态库缺点：动态库没有被打包到程序中，加载速度比较慢



25.链接的过程，主要做了什么？

**答：**我们把 \*.o 叫目标文件，实际上 *.o 文件只是目标文件的一种，目标文件的格式在Unix系统下被称为ELF格式（Executable and Linking Format，可执行和可链接格式），目标文件有三种：

1.可重定位目标文件

上面我们产生的*.o文件即 main.o 被称为可重定位目标文件，它与其他可重定位目标文件合并后生成可执行目标文件；典型的 ELF 可重定位目标文件格式如下

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/18.png" style="zoom:95%;" />![](https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/18.png)

​								可重定位目标文件 (*.o)																										可执行目标文件 (a.out)

2.可执行目标文件

我们生成的 a.out 就是可执行目标文件，它可以被加载到内存中运行，它的格式和可重定位目标文件类似，如上图所示，需要注意的是，其头部包括程序的入口点（entry point），也就是文件被载入内存后要执行的第一条指令的地址

3.共享目标文件

一种特殊的可重定位目标文件，可以在运行时被动态地加载到内存中链接，如一些动态库 .so 文件



链接的过程就是把目标文件中的一些相似的段整合到一起；但是这个过程需要分两步来完成

1.重定位：链接器通过把符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置

2.符号解析：每个符号对应一个函数，一个全局变量或一个静态变量，符号解析的目的就是将每个符号引用与一个符号定义关联起来

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/18%20%5B2%5D.png" style="zoom:80%;" /> 



21：可执行文件怎么运行起来的？

**答：**OS都有加载程序的功能，一个可执行文件（比如a.out文件）内部都是机器指令（与cpu相关）和数据，所以可执行文件和OS以及编译器是密切相关的，不同的OS下的不同的编译器产生的可执行文件都不尽相同 ( Linux下的可执行文件格式为ELF格式 )；大致都是以段的形式来表示 (里面存储的都是一个一个段的格式，如.text .data .bss)

而OS的功能就是读懂这些文件然后完成从磁盘文件到内存的映射工作，也就是在适当的时候把文件的内容搬到内存适当的位置

1.OS加载的过程就是进程创建的过程，进程创建完毕后，会找到 “入口函数” 去执行；

2.进入入口函数后就等于进入了运行库，因为入口函数就是运行库的一部分；

3.入口函数开始初始化运行程序所需的环境，比如堆的初始化，I/O初始化，线程的准备，全局变量等的初始化

4.下一步就是进入程序的主体，也就是调用main函数部分

5.main函数执行结束后又回到入口函数，此时入口函数要进行一些清理工作

6.清理完成后执行一个系统调用来 kill 掉进程



22.程序从可执行文件到屏幕输出的全过程？

**答：**C++第123问

1、用户告诉操作系统执行 HelloWorld 程序（通过键盘输入等）

2、操作系统：找到 helloworld 程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址

3、操作系统：创建一个新进程，将 HelloWorld 可执行文件映射到该进程结构，表示由该进程执行 helloworld 程序

4、操作系统：为 helloworld 程序设置cpu上下文环境，并跳到程序开始处

5、执行 helloworld 程序的第一条指令，发生缺页异常

6、操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行 helloworld 程序

7、helloword 程序执行 puts 函数（系统调用），在显示器上写一字符串

8、操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程

9、操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区

10、视频硬件将像素转换成显示器可接收和一组控制数据信号

11、显示器解释信号，激发液晶屏

12、OK，我们在屏幕上看到了 HelloWorld



22.C++程序crash (程序崩溃) 掉的几种情况

**答：**1.空指针访问  	2.野指针访问  	3.数据越界访问	 4.迭代器越界访问 	 5.除0异常 	 6.内存重复释放  	7.堆栈溢出

附：局部变量未初始化而直接访问并不会导致程序崩溃，但是结果会是一个垃圾值，这是编译器安排的一个值



15.程序怎么优化？

**答：**分为几个方面：1.程序代码方面 	 2.IO操作方面 	 3.进线程间通信和同步方面

1.程序代码方面 (编程语言层次)

1). 尽量减少值传递，多用引用来传递参数，如果参数是 int 等基本数据类型可能对性能的影响还不是很大，但是如果参数是一个类的对象，值传递会额外调用一次拷贝构造函数

2).能 ++i (前置++) 就不要 i++ (后置++)，因为后置++是先返回对象的拷贝，之后对象本身再自增；前置++是直接对源对象进行自增然后返回对象

3).避免太大的循环以及太大的内存占用，也就是优化程序中算法的时间复杂度和空间复杂度

4).减少除法运算的使用，无论是整数还是浮点数运算，除法都是一种运算速度很慢的指令，在计算机中实现除法是比较复杂的。所以要减少除法运算的次数

5).将小粒度函数声明为内联函数（inline）正如我们所知，调用函数是需要保护现场，为局部变量分配内存，函数结束后还要恢复现场等开销，而内联函数则是把它的代码直接嵌入到调用函数处，所以不需要这些开销，但会使程序的源代码体积变大

6).多用直接初始化，少在构造函数中执行赋值操作

2.IO操作方面：涉及到 socket 程序能用零拷贝就使用零拷贝，能用多用IO就用多路IO

3.进线程间通信和同步方面：能用无锁编程尽量使用无锁编程



24.coredump的情况遇到过吗？怎么处理？

**答：**

1.什么是coredump

我们经常听到大家说到程序core掉了，需要定位解决，这里说的大部分是指对应程序由于各种异常或者bug导致在运行过程中异常退出或者中止，并且在满足一定条件下（这里为什么说需要满足一定的条件呢？下面会分析）会产生一个叫做core的文件

通常情况下，core文件会包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息还有各种函数调用堆栈信息等，我们可以理解为是程序工作当前状态存储生成第一个文件，许多的程序出错的时候都会产生一个core文件，通过工具分析这个文件，我们可以定位到程序异常退出的时候对应的堆栈调用等信息，找出问题所在并进行及时解决

2.coredump文件的存储位置

core文件默认的存储位置与对应的可执行程序在同一目录下，文件名是core；也不是所有程序crash就都会生成core文件

3.产生coredump文件的一些条件总结 （默认是不会产生coredump的，需要自己设置开启）

产生coredump的条件，首先需要确认当前会话的 ulimit –c，若为0，则不会产生对应的coredump，需要进行修改和设置ulimit -c unlimited (可以产生coredump且不受大小限制)

若想修改对应的字符大小，则可以指定：ulimit –c [size]

4.产生coredump的几种情况 （就是上面进程crash的几种情况）



#### 动态内存分配

11.C++内存分配和C语言内存分配的new和malloc的区别

**答：**1.属性方面：new和delete是C++关键字 (也是运算符)，需要编译器支持；而malloc和free是库函数，需要头文件支持，使用malloc和free需要包含头文件<stdlib.h>；

由于new和delete是运算符，不是函数，因此执行效率要比malloc和free高；C++提倡用户使用new和delete运算符

2.参数方面：使用new操作符申请内存时无需指定内存块的大小，编译器会根据类型信息自动计算；而malloc函数需要显示地指出所需申请内存的大小

3.返回类型方面：用new分配内存成功时，返回的是**对象类型的指针，类型与对象严格匹配，无需强制转换**；如果由于内存不足等原因而无法正常分配空间，则会抛出 bad_alloc 异常

用malloc分配内存成功时，返回的是指向新分配内存首地址的**空类型**的指针，需要程序员执行类型转换将 (void*) 指针转换为所需要的类型 ( 其实即使程序员不强制转换，编译器也会自动转换，但为了程序的可读性，提倡自己强制转换 )； malloc申请内存失败是返回NULL  （谭浩强P285）

4.释放内存方面：

使用new会调用相应的构造函数：使用new会先调用operator new函数 (通常底层使用malloc实现)，申请足够的内存，然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针

使用delete会调用相应的析构函数：使用delete先调用析构函数，然后调用operator delete释放内存 ( 通常底层使用free实现 )；所以使用new申请的内存，只能由delete释放掉

而malloc/free是库函数，只能简单的申请和释放内存，无法强制要求其做出自定义类型对象的构造和析构工作；所以malloc申请的内存只能用free直接释放掉



补充：malloc和new都是在堆上申请内存

malloc是面向内存的，你要多大内存就给你开多大内存，开了就不管了；而new是面向对象的，根据你指定的数据类型来申请对应的空间，并且能够直接内部调用构造函数生成对象

对于非内部数据类型而言，malloc和free无法满足动态对象的要求；对象在创建时需要自动执行构造函数，在消亡之前需要自动执行析构函数；由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行的构造函数和析构函数强加于malloc/free，于是就有了new/delete



附：析构函数可以清除给定的对象但是不会释放该对象所在的内存空间，所以如果需要的话可以重新使用该空间  （《Primer》P730）

调用析构函数会销毁对象，但是不会释放对象所在内存

```C++
delete sp;
delete[] arr;
```

针对上面语句delete其实执行了两步操作

第一步：对sp指向的对象或者arr所指的数组中的元素执行对应的析构函数

第二部：编译器调用名为 operator delete（或者 operator delete[ ]）的标准库函数函数释放内存空间



附：new分配的内存能用delete[ ]释放掉吗？或者new[ ] 分配的内存能用 delete 释放掉吗？

**答：**关于动态申请的内存，分为基本数据类型和自定义数据类型，这两者有区别

1.对于基本数据类型

```C++
int *p = new int[10];
delete p;				//方式一
delete[] p;				//方式二
```

对于基本数据类型上面的两种方式都不会导致内存泄漏，因为基本数据类型对象没有析构函数，并且new在分配内存时会记录分配的空间大小，则delete能根据记录的空间大小来正确释放内存

2.对于自定义数据类型

一般是指类对象，假如通过new申请了一个对象数组，返回一个指针，对于此对象数组的内存释放，需要做两件事情

1.调用析构函数完成对对象的清理工作     2.释放掉对象占有的内存空间

而由于new的时候会记录申请空间的大小，所以无论是delete还是delete[ ]都能将这片空间释放，而问题就出现在析构函数的调用上；当使用delete时，仅仅调用对象数组中第一个对象的析构函数，而使用delete[ ]的话，就会对这一组对象每个都调用析构函数；如：

```C++
class Test {
public:
    Test() {}
    ~Test() { std::cout << "~Test" << std::endl; }
};

Test *p = new Test[10];
delete p;				//现在编译器很智能，这个错误可以被检测出来
delete[] p;				//正确释放内存
```

附：那既然内存都能释放掉，还有必要执行析构函数吗？

**答：**因为delete释放的是对象所占有的内存，但是如果对象中有指针成员指向堆中内存，那么不执行析构函数则这块内存就永远无法释放从而导致内存泄漏，而且有的资源比如文件描述符，端口使用了但是不释放会造成资源泄漏和浪费



12.malloc函数底层实现原理，malloc申请的8KB空间是否连续？

**答：** 虚拟地址空间的堆区内存分布

<img src="https://raw.githubusercontent.com/BoomChao/Windows_Figure/main/4.png" style="zoom:100%;" />



在已经映射的内存空间结尾有一个break指针，这个指针下面是映射好的内存，可以访问，上面则是未映射的内存，不能访问；rlimit则是限制进程堆内存容量的指针

Linux通过两个系统调用来操作堆内存

```C++
int brk(void *addr);              //成功返回0,失败返回-1
void *sbrk(intptr_t increment);   //成功返回之前break指向的位置,失败返回(void*)-1;        										  //sbrk(0)用来返回当前break指向的位置
```

brk 可以直接将 break 指针设置为指向某个地址，成功返回0，不成功返回-1

sbrk 能移动 break 指针的位置，同时返回移动 break 之前的位置

malloc 分配内存时先按照动态分区分配算法查找已经映射的区域有没有剩余空间可以使用，如果没有的话调用系统调用 sbrk来移动break指针的位置在堆中开辟新的空间



30.free(void *ptr)怎么正确释放指针？

**答：**使用 malloc 函数分配内存时候根据参数指定的大小，分配一块内存，然后返回这块内存的起始位置给调用者，这就是调用者拿到的所谓的指针

其实这个指针并不是真正的起始位置，真正的指针在malloc返回指针p的前面，内存分配器在p的前面用两个字节的空间来存放分配的内存大小信息

所以free函数释放时既要找到内存首地址，也要拿到前面的内存大小才能正确释放

附：如果前面这段存储内存大小信息的地址被破坏了，则解决方案是采取一定的校验措施来保证即使这段地址被破坏也能被发现



13.C++中利用new分配内存失败时，怎么让new不抛出异常而返回null?

**答：**在C++中，new有三种典型的使用方法：plain new，nothrow new 和 placement new

1、plain new是普通的new，就是我们常用的new，在C++中定义如下：

```C++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此 plain new 在空间分配失败的情况下，抛出异常 std::bad_alloc 而不是返回 NULL

```C++
#include <iostream>
int main() {
    std::cout << "hello" << std::endl;
    char *p;
    try {
        p = new char[10000000000000];
    } catch(std::bad_alloc x) {
        std::cout << "fail" << std::endl;
        return 0;
    }
    std::cout <<"success" << std::endl;
    delete[] p;
    
    return 0;
}
```



2、nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL

```C++
#include <iostream>
int main() {
    std::cout << "hello" << std::endl;
    char *p = new(std::nothrow) char[100000000];    //使用nothrow
    if(p==0) {
        std::cout << "fail" << std::endl;
        return -1;
    }
    std::cout << "success" << std::endl;
    return 0;
}
```



3、placement new 允许在一块已经分配成功的内存上重新构造对象或对象数组

placement new 不用担心内存分配失败，因为它根本不分配内存，它所做的唯一一件事情就是调用对象的构造函数

使用 placement new 需要注意两点：

1.palcement new 的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组

2.placement new 构造出的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为 placement new 构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用 delete 会造成内存泄漏或者之后释放内存时出现运行时错误

```C++
class ADT {
public:
    ADT() { std::cout << "ADT" << std::endl; }    
    ~ADT() { std::cout << "~ADT" << std::endl; }
};

char *p = new(std::nothrow) char[sizeof(ADT)+1];
if(p == NULL) std::cout << "Failed" << std::endl;
ADT *ptr = new(p) ADT;
ptr->ADT::~ADT();	//如果这里使用delete[] ptr; 则由于申请的内存空间大小为ADT+1,释放的话只会释放ADT对象所占的空间,所以会导致一个字节的内存泄露
delete[] p;
```



14.怎么设置只允许在堆上或者栈上创建对象

**答：**在C++中，类的对象建立分为两种，一种是静态建立；另一种是动态建立；这两种方式是有区别的，如：

```C++
A a;			//静态创建对象
A *p = new A();	//动态创建对象
```

1).静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数生成一个栈对象；使用这种方法，直接调用类的构造函数

2).动态建立类对象，是使用new运算符将对象建立在堆空间中；这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数

1.只允许在堆上创建对象

**答：**类对象只能建立在堆上，就是不能静态建立类对象，即不能直接调用类的构造函数

容易想到将构造函数设为私有，这样类外就无法调用构造函数构造对象，但是new的底层也会执行构造函数，这样也不能产生动态对象

所以将析构函数设置为私有，因为栈上分配的对象程序结束会自动调用析构函数，当编译器检查到析构函数私有时，则不会为栈上的对象分配内存

但是堆上的对象使用完后内存也需要释放掉，所以需要定义一个方法来间接访问类的私有成员函数，堆上的对象使用完我们手动调用这个方法释放掉内存；构造函数不能显示调用，但是析构函数可以显示调用

```C++
class A {
public:
    A() {}
    void destory() { delete this; }
private:
    ~A(){}
};
```

2.只允许在栈上创建对象

**答：**堆上创建的对象必须使用new关键字，所以将这个关键字禁用即可，也就是将 operator new( ) 设定为私有

```C++
class A {
private:
    void *operator new(size_t t) {}
    void operator delelte(void *ptr) {}        //重载了new就需要重载delete
public:
    A(){};
    ~A(){};
};
```





