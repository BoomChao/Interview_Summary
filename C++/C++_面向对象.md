### 面向对象

##### 1.C++三大特性，解释这三大特性     （第72问）

**答：**封装，继承，多态

封装：把客观事物封装成抽象的类，对自身的数据和方法进行，把数据和代码封装在一起，避免外界的干扰和不确定性访问，并且类可以设置自身数据对外界的访问权限

如：将公共的数据和方法使用public修饰，这是类为外界提供的接口；用于给派生类使用的数据可以声明为protected

而不希望外界访问的数据和方法用private修饰，保护成员则用于给我的派生类使用



继承：让某种类型的对象获得另一个类对象的属性和方法

继承实现方式有三大类：实现继承，接口继承和可视继承（可视继承在C++中不常用）

实现继承是指直接使用基类的属性和方法而无需额外编码的能力

接口继承是指仅使用基类属性和方法的名称，但是子类必须提供实现的能力

可视继承是指子窗体(类)使用基窗体(类)的外观和实现代码的能力

如：将人定义为一个抽象类，拥有姓名，性别，年龄等公共属性，吃饭，睡觉，走路等公共方法；在定义一个具体的人时就可以继承这个抽象类，即保留基类的公共属性和方法，也可以在此基础上扩展唱歌，跳舞等方法



多态：多态就是指同样的消息被不同类型的对象接收时导致不同的行为；所谓消息是指对类的成员函数的调用，不同的行为是指调用不同的函数

多态允许你将父对象设置成一个或者更多的他的子对象相等的计数，赋值之后父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作；允许将子类类型的地址赋值给父类类型的指针；

从多态实现的角度来分有编译时的多态和运行时的多态； 前者也称之为静态绑定(也称之为静态多态)，后者也称之为动态绑定(动态多态)；

函数重载就是静态绑定(需要注意运算符重载的实质就是函数重载，参看郑莉P307)； 动态绑定主要是通过虚函数来实现



##### 19.虚函数可以是内联函数吗	1.什么函数不能声明为虚函数？

**答：**回答这个问题首先要明确虚函数的作用是什么，虚函数的作用是实现动态多态性；

动态多态性的**特点就是不在编译时确定调用的是哪个函数，而是在程序运行过程中才动态的确定操作所针对的对象**

1.依据动态多态性的特点可知虚函数必须是非静态的成员函数，所以利用static声明的静态成员函数不能做虚函数      （1，2两点是依据动态多态的特点来答）

2.内联函数不能是虚函数；因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的，内联函数是在编译时将函数体嵌入在每一个调用处（郑莉P136，P81）

3.多态是依托于类的，普通函数(即非成员函数)就不能声明为虚函数             （3，4依据继承关系来回答）

4.友元函数不能是虚函数；C++不支持友元函数的继承，不能继承的函数不是虚函数

5.构造函数不能是虚函数；因为虚函数的作用在于通过基类的指针指向派生类的对象时，能访问到派生类中与基类同名的成员函数；而构造函数是在创建对象时自动调用的，不可能通过基类的指针或引用去显示调用;  换句话说就是执行构造函数时类对象还未完全建立，当然也就谈不上把函数和类对象绑定起来；(谭浩强 P392)；

虚函数主要是针对对象的，而构造函数是在对象产生之前运行的，因此虚构造函数没有意义



附：为何静态成员函数不能是虚函数？ （this指针见<郑莉P214>）

**答：**static成员函数不属于任何一个对象，它是属于类的，所有对象共有；静态成员函数与非静态成员函数的一个主要区别就在于静态成员函数是没有this指针；

而虚函数是依靠vptr (虚表指针) 和vtable (虚表)；虚表指针在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个隐含成员，虚表指针指向保存虚函数首地址的虚表

对于静态成员函数，它没有this指针，所以无法访问vptr，这就是为何static函数不能为virtual

虚函数的调用关系：this->vptr->vtable->virtual function



附：override关键字：C++11新标准允许派生类显示的注明它使用某个成员函数覆盖 (也叫重写) 了它继承的虚函数；具体做法是在形参列表后面，或者在const成员函数的const关键字后面添加一个关键字override

```c++
int Test::func() override; 			//或者如下
int Test::func() const override;
```

final关键字：C++11标准还提供了一个防止继承发生的手段，即不允许该类被继承，在类名后面添加一个final关键字

```c++
class Test final {};        //Test不能用作基类来继承
```

default关键字：通过将拷贝控制成员定义为 =default来显示的要求编译器生成该函数的默认版本，只能对默认构造函数或者拷贝控制成员使用 = default关键字

```c++
class Test {
public:
    Test() = default;
    Test(const Test&) = default;
    Test& operator=(const Test&);
    ~Test() = default;
};
Test& operator=(const Test&) = default;
//避免合成的函数内联 注：当我们在类内使用 =default 修饰成员的声明时，合成的函数将隐式声明为内联的；如果不希望生成的函数是内联的,应该只对成员的类外定义使用 =default
```

delete关键字：该关键字告诉编译器我们不希望使用这些成员函数，使用该关键字的函数称为删除的函数 (deleted function)

```c++
struct NoCopy {
    NoCopy() = default;
    NoCopy(const Nocopyt&) = delete;  //阻止拷贝
    NoCopyt& operator=(const NoCopy&) = delete;    //阻止赋值
};
```

附：或者将函数声明为private，只给出定义不给出实现也能达到上述效果（参看单例模式） 



##### 3虚函数怎么实现的，虚函数表的位置？2.虚函数的实现原理？虚函数表存的是什么？

**答：**虚函数的实现原理总结起来就是动态多态性；动态多态性的特点就是不在编译时确定调用的是哪个函数，而是在程序运行过程中才动态的确定操作所针对的对象；而虚函数实现多态这种特征就需要虚函数表；

当一个类中存在虚函数时，编译系统会为该类构造一个虚函数表（virtual function table，简称为 vtable)，虚函数表是一个指针数组，存放每个虚函数的入口地址  （谭浩强P391）

每个有虚函数的类各有一个虚表，虚表的内容是由编译器安排的；派生类的虚表中，基类声明的虚函数对应的指针放在前面，派生类新增的虚函数的对应指针放在后面，这样一个虚函数的指针在基类虚表和派生类虚表有相同的位置；每个多态类型的对象中都有一个指向当前类型的虚表的指针，该指针在构造函数中赋值；当通过基类的指针或者引用调用虚函数时，就可以通过虚表指针找到该对象的虚表，进而在虚表条目中找到存放该虚函数的指针；将该条目中存放的指针读出后，就可以获得应当被调用的函数的入口地址，然后调用该虚函数，**虚函数的动态绑定就是这样实现的**  (郑莉P342)



##### 2.1虚表指针，虚表是什么时候初始化的？

**答：**虚表指针跟着对象走，类对象什么时候被创建出来则vptr就什么时候被创建出来；对象是在程序运行过程中被创建出来的，所以vptr也就是在程序运行过程中被创建的

虚函数表创建时机是在编译期间，编译期间编译器就为每个类确定好了对应的虚函数表的内容，所以程序在运行期间，编译器就会把虚函数表的首地址赋值给虚函数表指针，那么这个虚函数表指针就被初始化了



##### 26.类的每个实例化对象都有虚表指针吗？  （题目问的是一个类实列化多个对象，是否这些对象都各自有自己的虚表指针？）

**答：**虚表是针对类的，虚表指针是针对对象而言的；所以同一个类实例化多个对象，这些对象有各自的虚表指针，但是共用一块虚表；即这些对象的虚表指针的指向都是相同的，指向同一个虚表



##### 27.为什么析构函数可以是虚函数？ 

**答：**析构函数的功能就是在类对象消亡之前进行一些必要的清理工作，**如果一个类的析构函数是虚函数，则由其派生而来的所有子类的析构函数也是虚函数**；析构函数设置成虚函数后，在使用指针或引用时就可以实现动态绑定，实现运行时的多态，保证使用基类的指针就能够调用适当的析构函数针对不同的对象进行清理工作  （郑莉P320）



##### 28.C++的析构函数为什么要用virtual修饰？3.虚析构函数的作用？

**答：**注：这里虚析构函数都是指的在基类的析构函数上加上一个 virtual; 不存在说基类没有定义虚析构函数，而派生类定义了一个虚析构函数，不存在这种用法；

如果将基类的析构函数声明为虚函数时，无论基类指针指向的是同一类族中的哪一个类对象，系统都会采用**动态关联**，调用相应类的析构函数，对该对象进行清理工作；(谭浩强P392)

即如果我定义了一个基类指针指向派生类对象，在对象撤销之前(即程序调用结束之前)，那么在执行析构函数时就会先执行派生类的析构函数，再执行基类的析构函数；而不是仅执行基类的析构函数

注意：如果不是定义一个基类指针指向派生类对象，而是直接用派生类构造了一个对象，**此时即使基类的析构函数没有声明为虚析构函数**，对象撤销之前(即程序调用结束之前)，也会逐级往上调用析构函数，即先调用派生类的析构函数，再调用基类的析构函数；

附：我们通常将基类析构函数声明了虚函数，原因如下

```c++
class  A {
public:
    A() { printf("A"); }
    ~A() { printf("~A"); }
};

class B : public A{
public:
    B() { printf("B"); }
    ~B() { printf("~B"); }
}

int main() {
    A *a = new B;        //注：这里B的构造函数是无参构造，后面的括号加不加都行，即写成 A *c = new B(); 也可以
    delete a;
}
```

对上面的程序，如果不将基类的析构函数声明为虚函数，结果如下：AB~A；我们发现仅仅调用了基类的析构函数，而派生类的析构函数并没有调用，此时派生类就会导致内存泄露

将基类的析构函数声明为虚函数之后，系统就会采用动态关联，从而保证基类指针能够调用适当的析构函数对不同的对象进行清理工作



##### 4.虚函数可以为private吗？

**答：**虚函数可以为private，并且可以被子类覆盖掉

```c++
class Base {
private:
    virtual void fun() { std::cout << "Base" << std::endl; }
    frient int main();       // 这一行一定要加，否则编译不通过；
};

class Derived : public Base {
public:
    void fun() { std::cout << "Derived" << std::endl; }
};

int main() {
    Base *ptr = new Derived;
    ptr->fun();
    return 0;
}
```

注意：int main( ) 是Base类的友元函数，如果删除这个友元声明，则程序会编译失败；

因为在**编译期间，会进行静态类型检查**，对于这行代码ptr->fun( )，由于ptr是Base对象类型的指针，编译器首先会检查Base类是否存在fun( )这个函数，之后还会检查外界是否会有访问权限；由于编译器会检查到fun是私有函数，base类型的对象/指针无权访问

上面的程序就说明了虚函数的重载性与其声明的权限无关

附：说说友元函数  （《Primer》P242）

类也可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元；如果想把一个函数作为它的友元，只需要增加一条以 friend 关键字开始的函数声明语句即可

1.友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，因为友元函数不是类的成员，也不受它所在区域的访问控制级别的限制，意思就是放在public, private, protected下都行

2.友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明；如果我们希望类的用户能够调用某个友元函数，那么必须在友元声明之外再专门对函数进行一次声明

3.友元函数也可以定义在类的内部



##### 28.虚继承     （《C++primer》P717）

**答：**首先明确一点：虚继承和虚函数是完全无相关的两个概念

虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：

其一，浪费存储空间；

第二，存在二义性问题，通常可以令基类指针指向派生类对象，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性；如果你用基类指针指向派生类后，再用基类指针调用基类的函数，编译器就不知道你调用的是从哪个途径继承来的基类；所以编译的时候就直接报错了

class 派生类名：virtual 继承方式 基类名     // virtual 和继承方式的顺序可以任意颠倒；virtual是关键字，声明该基类为派生类的虚基类

在多继承情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用。声明了虚基类之后，虚基类在进一步派生过程中始终和派生类一起，维护同一个基类子对象的拷贝

虚继承底层实现原理与编译器相关，一般通过虚基类表指针和虚基类表实现，每个虚继承的子类都有一个虚基类表指针（占用一个指针的存储空间，8字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类表指针也会被继承

实际上，bptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚基类表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间

虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体；如：

```c++
class A {};                            //sizeof A = 1, 空对象，只有一个字节用于占位
class B : virtual public A {};         //sizeof B = 8; 一个虚基类表指针 (bptr)
class C : virtual public A {};         //sizeof C = 8; 一个虚基类表指针 (bptr)
class D : public B, public C {};       //sizeof D = 16; 虚基类表指针也会被继承
```



附：含有虚基类的对象的构造顺序与一般的顺序稍为区别：首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类部分，接下来按照直接基类在派生类继承声明列表中出现的次序依次进行初始化，直接基类对虚基类构造函数的调用都自动被忽略，此即为菱形继承的初始化顺序  （primer P720）

```c++
class Base0 {
public:
    Base0(int var):var0(var) {}
    int var0;
};
class Base1 : virtual public Base0 {
public:
    Base1(int var):Base0(var) {}
    int var1;
};
class Base2 : virtual public Base0 {
public:
    Base2(int var):Base0(var) {}
    int var2;
};
class Derived : public Base1, public Base2 {
public:
    Derived(int var):Base0(var),Base1(var),Base2(var) {}   
    //注意虚基类的构造函数只会在最底层的派生类中执行一次,其他直接基类(Base1,Base2)会自动忽略对虚基类的构造
    int var;
};
```



附：多继承的优缺点？

**答：**1).C++允许多个派生类指定多个基类，这样的继承结构被称为多重继承，多重继承的优点很明显，就是对象可以调用多个基类中的接口

2).如果派生类所继承的多个基类具有相同的基类，而派生类的对象需要调用这个祖先类的接口方法，就会出现二义性，因为不知道你是调用的是从哪个路径继承下来的基类对象

解决方法：1.加上全局限定符确定调用的是哪一份拷贝     2.使用虚拟继承

```c++
class A {
public:
    void print() {}
};

class B : public A {};            //1.使用虚继承, virtual public A
class C : public A {};
class D : public B, public C {};       

D d;
d.print();    //2.这会有二义性,改成 d.B::print(); 表示使用从B这条继承路径下的基类;    或者 d.C::print();  或者使用 1.虚继承
```



##### 5.overload、override 和 overwrite的区别？	6.重载和重写(覆盖)以及隐藏的区别？     (郑莉P84)

**答：**overlaod叫重载  override叫重写(覆盖)   overwrite叫隐藏

两个以上的函数，具有相同的函数名，但是参数的个数或者类型不同(参数和类型可以都不同)，编译器就会根据实参和形参的类型及个数的最佳匹配，自动确定来调用哪一个函数，此即为**重载**；

**重写**也叫覆盖，是指两个以上的函数，函数名相同，参数和返回类型都相同；一般多用于类的继承中，将基类中与派生类同名的函数声明为虚函数

简而言之：无论重载还是重写，函数名都是相同的，但是重载的话参数个数或者类型不相同，而重写的话参数个数及其类型以及返回值类型都相同，所以重写一般多用于类的继承中，将基类中与派生类同名的函数声明为虚函数

**隐藏**是指派生类的函数屏蔽了其同名的基类函数，规则如下：

1.如果派生类的函数与基类的函数同名，但是参数不同；此时无论有无virtual关键字，基类的函数将被隐藏 （注意与重写区别开，通常基类的public成员函数在派生类中也可以使用，但是隐藏的话就不可见了，基类的成员函数在派生类中就被屏蔽掉了）

2.如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字；此时基类的函数将被隐藏



补充：需要注意使用默认形参值的函数重载形式时，需要防止二义性，如：

```c++
void fun(int length, int width = 2, int height = 3);        
void fun(int length);
//调用fun(1)直接报错，无法匹配
```

如：void fun(int);  long fun(int);  int fun(int);     （谭P102）

上面这种重载也是错误的，因为参数个数和类型都相同；而重载函数中的参数个数，参数类型和参数顺序三者中至少有一个不同；这也说明返回值类型不能作为重载函数的区分标准

编译器不知道该调用哪种函数，这种写法语法上就是错误的



##### 22.函数重写是什么？需不需要返回值类型也一致？

**答：**函数重写也称为覆盖，指的是两个及以上的函数，函数名相同，参数相同，返回值类型也相同；通常多用于类的继承中，将子类中与父类中的同名函数声明为虚函数；函数重写返回值类型必须一致；否则编译器会报错

比如下面这三个函数：

```c++
void fun(int);    
long fun(int);     
int fun(int);
//现在我调用 fun(5)； 编译器不知道该去找哪个函数         
```

返回值类型作为函数运行之后的一个状态，它是保持函数的调用者与被调用者之间进行通信的关键，但是不能作为某个函数的表示，所以通过返回类型并不能区分重载的函数，应该根据函数名是否相同并且函数中的参数去区分



##### 23.C++构造和析构函数可以抛出异常吗？

**答：**语法上C++构造函数和析构函数都可以抛出异常，但是从逻辑上和风险控制上，构造函数可以，析构函数不推荐抛出异常

1.构造函数可以抛出异常

无论何时，从构造函数中抛出异常都是可以的。动态创建对象要进行两个操作：分配内存和调用构造函数。若在分配内存时出错，会抛出bad_alloc异常；**若在调用构造函数初始化时出错，会不会存在内存泄漏呢？答案是不会**

new运算符保证不会出现内存泄漏

```c++
T *p = new T;	//将会被编译器转换成类似下面的样子

void allocate_and_construct()
{
    //第一步：分配原始内存，若失败则抛出bad_alloc异常
    try {
        new(p) T;	//placement new; 只调用T的构造函数
    }
    catch(...) {
        delete p;	//只释放第一步分配的内存
        throw;		//重抛异常，通常应用程序
    }
}
```



(2)析构函数不推荐抛出异常，如果析构函数可能抛出异常，那么必须要求在析构函数内消化所有异常或者结束程序
more effective c++提出两点理由（析构函数不能抛出异常的理由）

1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 **正常情况下调用析构函数抛出异常导致资源泄露**

2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。 **在发生异常的情况下调用析构函数抛出异常，会导致程序崩溃**

解决方案：

1.如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作；目的是给客户一个处理错误的机会

2.如果析构函数中异常非抛不可，那就用try catch来将异常吞下，必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。



##### 38.能否在构造函数和析构函数中调用虚函数？

**答：**从语法上讲，上述调用完全可以，但是从效果上来讲往往不能达成需要的目的；所以不要在构造或者析构函数中调用虚函数     （《Effective》条款9）

因为派生类对象构造期间进入基类的构造函数时，虚函数的对象类型变成了基类类型而不是派生类类型；同样进入基类析构函数时，虚函数的对象也是基类类型



##### 23.C语言有重载吗？C++函数重载的原理

**答：**C语言没有函数重载

C语言不能函数重载与函数编译后的函数名相关；C语言编译后的代码

比如现在一个函数的声明如下：void function(int x, int y)

在C语言中，编译完成后在库中的名字为 _function；而在C++中编译完成后在库中的名字为 _function_int_int

现在还有一个同名的函数 ：void function(float x, float y)

在C语言中，编译完成后在库中的名字为 _function；而在C++中编译完成后在库中的名字为 _function_float_float

但是在链接时，都是找名字进行连接的，就比如上面两个函数，由于在C语言中名字都一样，就会在链接中报错，但是C++中它们的名字不一样，所以就不会报错

所以C语言不支持函数重载，而C++支持函数重载



附：C++有些操作符是不能重载的，它们是类属关系运算符"."，成员指针运算符 ".*"，作用域分辨符 "::"，和三目运算符 "?:" 以及 sizeof 运算符

前两个运算符保证了C++中访问成员功能的含义不会被改变，作用域分辨符和sizeof运算符的操作数是类型，而不是普通的表达式，故不具备重载的含义

注：new 和 delete也是可以被重载的



##### 5.类的成员初始化有几种方式？这两种方式有什么差异？

**答：**初始化类的成员有两种方式：1.使用初始化列表**初始化**   2.在构造函数体内进行**赋值操作**

必须使用初始化列表初始化成员的四种情形

1.const修饰的常量成员，因为常量成员只能初始化不能赋值，所以必须放在初始化列表中

2.引用类型，引用必须在定义的时候初始化，并且不能被重新赋值，所以也要写在初始化列表中      注：1，2这两种情况绝对不能放在构造函数内，因为构造函数内执行的是赋值操作

3.当类B包含另外一个类A的对象作为其成员时，且类A没有默认构造函数，则只能使用列表初始化

```C++
class A {
public:
    A(int m_val) : val(m_val) { }
private:
    int val;
};

class B {
public:
    B(A &m_a) { a(m_a); }        
    //无法通过编译，因为构造函数体内执行的是赋值操作，进入构造函数体内对象a已经被初始化完了，但是由于没有默认的初始化函数，故报错
    B(A &m_a) : a(m_a) { }        //改为这样就正确
private:
    A a;
};
```

4.当类为派生类，且想要初始化基类成员时，需要使用初始化列表

```C++
class Base {
public:
    Base() {}
    Base(int m_val) : val(m_val) {}
    int val;
};
class Derived : public Base {
public:
    Derived(int m_val) : val(m_val) {}	
    //错误1：派生类只能初始化自己新增的成员，基类的成员必须由基类来初始化，这会报错Derived没有val这个成员
    Derived(int m_val) { val = m_val; }
    //正确：因为进入构造函数后基类执行了默认初始化，而由于val在基类的属性为public,所以派生类可以继承该成员对其进行赋值
    
    //错误二：由于执行构造函数之前已经隐士调用了基类的Base的无参构造函数，此时内部欲对其初始化，直接编译不通过，和上面第3条一样
    Derived(int m_val) { Base(m_val); }
    Derived(int m_val): Base(m_val) {}	//正确，使用列表初始化基类成员
};
```

冒号初始化 (初始化列表初始化) 与函数体初始化的区别在于：

1.冒号初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式( 此表达式必须是括号赋值表达式 )，那么分配了内存空间后进入函数体之前就给数据成员赋值，就是说初始化这个数据成员时函数体还未执行

2.对于在函数体中初始化( 其实准确叫法应该是在函数体内被赋值 )，是在所有的数据成员被分配内存空间后才进行的



附：如果自己显示声明了构造函数，编译器就不会自动产生一个无参数的默认构造函数，只有当自己没有显示声明构造函数时，编译器才会为我们加上一个默认构造函数

```C++
class Test {
public:
    Test() = defalut;
    Test(int m_x) {}
};

Test *p1 = new Test();	//如果没有上面的default语句则这样写是错误的
Test *p2 = new Test(2);	//正确
```



##### 5.构造函数，拷贝构造(复制构造)函数和赋值函数的区别      

注：准确来说只有拷贝构造(也叫复制构造)，没有赋值构造这一说，或者将其理解为 赋值构造是通过重载赋值运算符来实现的

**答：**

1).构造函数是一种特殊的类成员函数，是当创建一个类的对象时，它被调用来对类的数据成员进行初始化和分配内存

构造函数可以被重载，可以多个；析构函数只能有一个，不能被重载，不带参数；而默认构造函数没有参数，它什么也不做；当没有自定义构造函数时，编译器就会默认添加一个默认构造函数

2).拷贝构造函数是用一个已经存在的对象构造和初始化一个新的对象

当没有重载拷贝构造函数时，都是通过默认拷贝函数来创建一个对象

```C++
A a;
A b(a); /*或*/ A b = a;	//这两种写法都是通过拷贝构造函数来创建对象b,默认的拷贝构造函数是浅拷贝
//注意：这里b对象之前是不存在的，使用 a 对象来构造和初始化b的
```

注意在拷贝构造的过程中，编译器可以 (但不是必须) 跳过拷贝构造函数，直接创建对象

即编译器被允许将下面的代码 string str = "123";  改写为 string str("123");

3).赋值运算：当一个类的对象对该类的另一个对象赋值时就会调用到该类的赋值函数

```C++
A a, b;
b = a;		//将对象a赋值给b
//注意：这里对象a,b是已经存在的，使用a对象赋值给b对象
```

简而言之：

对象不存在，且没有用别的对象来初始化，就是调用了构造函数

对象不存在，且用别的对象来初始化，就是调用了拷贝构造函数

对象存在，用别的对象来给它赋值，就是调用了赋值运算 ( 实际是内部通过重载赋值运算符实现 )



附：对于一个空类，编译器会加入以下默认的成员函数

1.默认构造函数和拷贝构造函数(也叫复制构造函数)  	2.析构函数  	3.重载的赋值运算符

```C++
Empty();	//默认构造函数
Empty(const Empty &);	//默认拷贝构造函数
~Empty();	//析构函数
Empty& operator=(const Empty&);		//赋值运算符
```

上面的四个函数即使类中未给出任何实现，编译器也会自动加入这些默认的函数



附：直接初始化和拷贝初始化的区别

```C++
class A {
public:
    A(int a) {}
    A(const A &a) {}
};

A a(1);
A b = 1;	//如果构造函数前面加上explicit关键字，则该句编译出错，因为b=1实际上执行的是隐式转换，转而去执行构造函数，但是现在使用explicit关键字禁止隐式转换构造函数
A c = b;	//如果在拷贝构造函数前面加上explicit关键字，则该句编译出错；因为c=b实际上会执行隐私转换，转而去执行拷贝构造函数，但是现在explicit禁止隐式转换拷贝构造
```



##### 6.调用拷贝构造函数的三种情况

**答：**只有这三种情况下会调用拷贝构造函数

1).当用一个已经存在的对象去初始化构造一个新对象时     

2).如果函数形参是类对象，则形实结合的过程中会发生拷贝构造

3).如果函数返回值是类对象，函数执行完成返回调用时也会发生一次拷贝构造（构造一个临时对象用于返回）

```C++
Test {
public:
    Test() { std::cout << "构造" << std::endl; }
    Test(const Test &demo) { std::cout << "拷贝构造" << std::endl; }
    Test& operator=(const Test &demo) { std::cout << "赋值" << std::endl; } 
};

Test fun() {
    Test a;
    return a;
}

fun();    		   //一次构造，一次拷贝构造    
Test b = fun();    //一次构造，两次拷贝构造
```

此处调用函数 fun() 会发生一次函数内部的构造函数调用以及函数执行完成会产生一个临时对象，也会发生一次拷贝构造但是实际编译器会对此进行优化，gcc做了优化，返回值为对象时，不再产生临时对象，因此不会调用拷贝构造函数，如果想让gcc不做优化，则加上参数 -fno-elide-constructors



附：分析下面程序函数的执行顺序（题目出的非常好）

```C++
string fun(string s1, string s2) {            //两次拷贝构造
    string tmp = s1 + s2;                    //一次构造，函数调用结束产生临时值发生拷贝构造，将临时值赋值给tmp发生一次拷贝构造
    return tmp;                              //返回临时值发生一次拷贝构造
}
```

1.首先形实结合的过程中会发生拷贝构造，所以先会发生s1和s2的两次拷贝构造

2.之后是重载的'+'运算符，这个运算符返回的是一个对象值，所以内部会发生一个新对象的构造，函数返回临时对象会发生一次拷贝构造，之后将这个临时对象赋值给tmp会发生一次拷贝构造

3.fun函数返回临时值发生一次拷贝构造



##### 31.临时变量为什么可以作为函数的返回值，不是局部变量当函数调用结束该变量的值就释放掉了吗？  （第89问）

**答：**首先，临时变量在函数调用过程中是被压到程序进程栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，但临时变量占用的内存空间却没有被销毁，但是已经可以被分配给其他变量了(即分配给调用函数的变量)，所以在函数退出时，该内存已经被修改了，对于此时临时变量来说已经是没有意义的值了

函数调用结束时返回值被临时存储到寄存器中，并没有保存到堆或者栈中，也就是说与内存没有关系了；当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系；如果我们需要返回值，一般使用赋值语句就可以：A a = fun( )；



##### 6.复制构造函数(也叫拷贝构造函数)为什么传递的是引用，而不直接使用值传递？

**答：**是为了防止无限递归，调用复制构造函数时需要传入实参，如果是值传递，则在形实结合的过程中就会再一次调用复制构造函数，如此下去就会形成永无休止的递归调用而导致栈溢出



##### 7.C++存在哪些构造函数？

**答：**构造，拷贝构造，移动构造，委托构造，转换构造

对于委托构造函数：必须要求有一个默认的构造函数，即类中不能全是委托构造函数，要不然委托构造函数不能指定委托的对象

转换构造函数作用是将其他类型的变量隐式转换成本类对象：形参是其他类型变量，且只有一个形参

```c++
class Student {
public:
    int id, age;
    Student(int m_id, int m_age) : id(m_id), age(m_age) {}	//默认构造
    Student(int r) {	//转换构造
        id = 1000;
        age = r;
    }
    Student operator+(const Student &demo) const {
        return Student(id, age + demo.age);
    }
};

Student s1(1, 100);
Student s2 = s1 + 111;		//这就是执行了转换构造
//1.首先调用 "+" 运算符，发现111不是Student类的对象，而是int类型
//2.然后调用转换构造函数，将111变成Student(111)
//3.现在便可以进行加法运算, 其值为 s1.age + (TempStudentObject).age = 100 + 111 = 211
```



##### 42.C++中类里面的static变量和普通的成员变量有什么区别，static函数又与普通的成员函数有什么区别？

44.静态成员函数能访问普通成员变量和静态成员变量吗？普通成员函数能访问普通成员变量和静态成员变量吗？

**答：**类中static声明的变量是属于这个类的，而不属于任何一个具体对象，也就是任何一个对象都能访问到这个静态成员变量；而普通的成员变量是从属于具体的一个对象

静态成员函数通常是专门用来访问类中的静态成员；如果需要访问非静态成员 (也就是普通成员)，必须要借助对象名，**这是因为对静态成员函数的调用是没有目的对象的** (因为静态成员是针对类的，不是针对对象)，因此不能像非静态成员函数那样，隐含地通过目的对象访问类的非静态成员  （郑莉P157）

```C++
class A {
public:
    A(int m_x): x(m_x) {} 
    static void f(A a);
    
private:
    int x;
};

void A::f(A a) {
    std::cout << a.x << std::endl;
}

A demo(100);
A::f(demo); /*或者*/ demo.f(demo);
```



##### 21.虚函数和纯虚函数区别？

22.带纯虚函数的抽象类能实例化吗，为什么？派生类要实现纯虚函数的函数体吗，为什么？

**答：**因为抽象类里面包含有纯虚函数，所以抽象类不能被实例化；可以这么理解：如果抽象类能实例化，那么这个抽象类对象就具有抽象类里面纯虚函数的功能，但是抽象类中的纯虚函数中只有声明语句，没有实现语句，这个函数的功能从何而来；C++为了避免这种情况，禁止实例化抽象类

派生类如果给出了所有纯虚函数的实现，则这个派生类就可以定义自己的对象；反之如果派生类没有给出全部的纯虚函数的实现，则这个派生类仍然是抽象类

```C++
class A {
public:
    A(){}
    virtual show();            //.cc文件中实现
    virtual express() = 0；    //纯虚函数,不需要给出实现
    virtual ~A();              //.cc文件中实现
};
```

纯虚析构函数：当需要定义一个抽象类，而类中又没有其他纯虚函数，因为至少包含一个纯虚函数才能成为抽象类，因此可以将虚析构函数设置为纯虚的

```C++
class A {
public:
    A(){}
    virtual ~A() = 0;
};
A::~A(){}    //纯虚析构函数必须要给出定义(其他的不需要),因为派生类析构时,需要调用基类的析构函数,所以要保证为它提供函数体,否则会报错
```

注：抽象类不能被实例化，但是派生类对象构造时仍然调用了抽象类中的构造函数，不要认为抽象类不能实例化就不能调用其构造函数，只要是继承关系，派生类实例化第一个调用的函数永远都是基类构造函数



##### 26.C++类成员在内存中的存储方式

**答：**用类去定义对象时，系统会为每一个对象分配存储空间；按理说如果一个类包含数据和函数，要分别为数据和函数的代码去分配空间；那么如果用一个类定义了10个对象，那么就需要分别为10个对象的数据和代码分配存储单元，这样消耗的资源太多；于是为了节省空间，是否能够只用一段空间来存放这个共同的函数代码段，在调用各函数的对象时，都去调用这个公用的函数代码，显然这样做可以大大节约存储空间，C++编译系统就是这么做的；

因此每个对象所占用的空间只是该对象的数据部分 (虚函数指针和虚基类指针也属于数据部分) 所占用的空间，而不包括函数代码所占用的空间

类的静态成员变量存放在常量存储区，静态成员函数和非静态成员函数都是存放在代码段



附：理论上静态成员函数和非静态成员函数都是在类定义的时候存放在代码段的，因而可以说它们都是属于类的，但是为什么类只能直接调用静态成员函数，而非静态成员函数只有通过类对象才能调用呢？

**答：**因为类的非静态成员函数其实都内含了一个指向类对象的指针型参数(this指针)，对非静态成员函数的调用都是通过this指针来调用的，因而只有类对象才能调用(此时this指针才有实值)





### 模板机制

##### 5.函数实现一般放在.cpp文件中，stl中的模板函数实现为什么放在头文件中？

这个问题回答时最好能举例回答，把下面的文件写出再依据例子回答，这个问题的关键在于明确什么时候模板函数被实例化

**答：**模板函数的实例化是在编译阶段确定的，也就是说在编译过程中，模板被实例为几个实际的函数或者类就已经确定了；  

```C++
// add.h 文件
template<typename T>
T add(const T num1, const T num2);
```

```c++
// add.cc 文件
#include "add.h"
template<typename T>
T add(const T num1, const T num2) {
    return num1 + num2;
}
```

```C++
// main.cc文件
#include "add.h"
#include <iostream>
int main() {
    int n1 = 1, n2 = 2;
    std::cout << add(1, 2) << std::endl;
}
```

这样写程序会报错；**编译能通过，但是链接会出错**

add.cc 文件编译过程就是模板函数方法的实例化的过程，**这个过程会根据其他文件的引入情况去形成对应的函数实现**，但是由于main函数没有引入文件add.cc；那么add.cc在编译过程中依然可以生成add.o文件，但是这个add.o文件什么都没有；       （比如若main.cc文件引入了add.cc, 则main.cc编译后会生成对应的返回值为int型的模板函数的实现）

main.cc 文件编译的时候，因为开头引入了头文件add.h，它就知道有一个函数方法，但是由于头文件没有实现这个函数方法，编译器就会以为其他地方会实现这个函数方法(也就是等待链接的时候将该实现方法链接进来)；但是在链接的时候 add.o 文件是一个空的，没有函数的实现；那么编译器链接生成可执行文件时就会报错

**补充：**将类的定义文件(.h文件)和类的实现文件(.cpp文件)以及类的使用文件(.cpp, 主函数文件)分开的好处是：比如我现在在类中新增了一个函数，只需要将类的.cpp文件重新编译即可，而主函数文件不需要重新编译；如果将所有文件都放在一个文件下，则做任何更改都要将整个文件重新编译，没有这个必要，对大型程序这种操作很费时

附：一个函数模板就是一个公式，可用来生成针对特定类型的函数版本



模板类和模板函数的区别是什么？

**答：**函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显示的指定；即函数模板允许隐式调用和显式调用而类模板只能显式调用

为了使用类模板，必须要在模板名后面的尖括号中提供额外信息，用来代替模板参数的模板实参列表



函数重载和函数模板的区别？

**答：**相对于函数重载而言，模板具有的优势就是它不需要重复定义，它是根据具体的参数类型来实例化相对应的函数，但是函数模板只适用于函数的参数个数相同而类型不同，且函数体相同的情况，如果参数的个数不同，则不能使用函数模板



函数模板可以被另外一个模板或者一个普通非模板函数重载；与往常一样，名字相同的函数必须具有不同数量或类型的参数     （\<Primer> P616）

如果涉及到函数模板，则函数的匹配规则如下：

1.对于一个函数调用，其候选函数包括所有模板实参推断成功的函数模板实例

2.可行函数 ( 模板与非模板 ) 按照类型转换来排序

3.如果同样好的函数中只有一个是非模板函数，则选择此函数       //这里的同样好指的是这些函数参数都能匹配

4.如果同样好的函数中没有非模板函数，而有多个模板函数，且其中一个模板比其他模板更特例化，则选择该模板

5.否则，此调用存在歧义

```C++
int func(int x);

template<typename T>
int func(T x);

fun(1);		//模板函数与普通函数重载，优先调用非模板函数
```

```C++
template<typename T>		//版本一
void debug(const T &t) {
    std::cout << "Version 1" << std::endl;
}

template<typename T>		//版本二
void debug(T *p) {
    std::cout << "Version 2" << std::endl;
}

string s("hi");
debug(&s);	//这调用的是版本二，版本二实例化成debug(string*), 版本一实例化成debug(const string* &)
// 第一个版本的实例化需要进行普通指针到cosnt指针的强制转换，所以编译器优先第二个版本

const string *sp = &s;
debug(sp);	// 调用的也是版本二
// 版本二实例化为deubg(const string*), 版本一实例化成debug(const string *&);
// 这种情况根据实例化的结果来看，都会发生强制类型转换，但是为什么会调用的是版本二
// 因为函数调用规则有一条就是选择更特例化的版本，本质上模板一 debug(const T&) 可以用于任何类型，包括指针类型,模板一比模板二更加通用，而版本二只能用于指针类型，所以会优先调用版本二
```



附：写一个模板，判断一个变量是否为指针变量

```C++
template<class T>
bool isPtr(T *p) {
    return true;
}

bool isPtr(...) {    //"..."表示可接收任何参数
    return false;
}

int n = 1;
int *p = &n;
bool isPtr(p);    //按照函数模板匹配规则，优先匹配版本一，输出true
bool isPtr(n);    //匹配版本二，输出false
```



模板特例化

如果一个模板函数能够适应所有的模板实参，也就是传入任何参数都能实例化，这当然是最好的；但是实际情况中，往往通用模板的定义对特定类型是不合适的，通用定义可能编译失败或者做的不正确；所以当我们不能或者不想使用通用模板版本时，就可以定义类或函数模板的一个特例化版本

```C++
template<class T>                        //版本一：可以比较任意两个类型
int compare(const T &a, const T &b) {
    return a < b;
}

template<size_t N, size_t M>		//版本二：用来处理字符串字面常量
int compare(const char(&)[N], const char(&)[M]) {
    for(int i = 0; i < std::min(N, M); i++) {
        if(a[i] == b[i]) continue;
        else return a[i] < b[i];
    }
    return -1;
}

const char *p1 = "hi", *p2 = "mom";
compare(p1, p2);                        //调用第一个版本
compare("hi", "mom");                   //调用有两个非类型参数的版本
```

当定义函数模板的实例化版本时，其实就相当于为原模版的一个特殊实例提供了定义；一个模板特例化本质上是一个实例，而非函数名的一个重载版本



可变参数模板  （\<primer> P618）

一个可变参数模板就是一个接收可变数目参数的模板函数或模板类

可变参数的数目称为参数包；存在两种参数包

模板参数包：表示零个或者多个模板类型参数；  函数参数包：表示零个或者多个函数参数

我们用一个省略号来指出一个模板参数或者函数参数表示一个包，在一个模板参数列表中，class... 或 typename... 指出接下来的参数表示零个或者多个类型的列表

一个类型名后面跟一个省略号表示零个或者多个给定类型的参数列表

```C++
template<typename ... Args>		//Args是一个模板参数包；rest是一个函数参数包 
void g(Args ... rest) {			//Args表示零个或者多个模板类型参数，rest表示零个或者多个函数参数
    std::cout << sizeof...(Args);	//(sizeof...)运算符用来计算可变参数的数目
    std::cout << sizeof...(rest);
}
```

