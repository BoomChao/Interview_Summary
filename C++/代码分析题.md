1.判断下面代码结果

```C++
void get_memory(char *p, int n) {
    p = (char*)malloc(n);		//修改的是p的拷贝
}

//正确写法如下,改为传入指针的指针
void get_memoryNew(char **p, int n) {
    *p = (char*)malloc(n);
}

int main() {
    char *str = NULL;
    get_memory(str, 100);
    strcpy(str, "hello world");
    printf("%s\n", str);
    free(str);
    
    return 0;
}
```

使用指针来创建字符串和使用字符数组来创建字符的差别在于：

```C++
char *s = "hello"; 	/*等价于*/	const char *s = "hello";
char s[] = "hello";	 //使用指针创建的字符串只能读，使用数组创建的字符串不仅可以读，而且可以修改
```

但是上一题的错误在于指针传递也是值传递，get_memory函数里面修改的其实是传入的指针str的拷贝



2.判断下面代码结果

```C++
void fun(int *p1, int *p2, int *t)
{
    t = (int *)malloc(sizeof(int));    //这是修改指针的拷贝的值
    *t = *p1 + *(p2++);                //输出*t的值为11
}
int main()
{
    int a[2] = { 1,2 };
    int b[2] = { 10,20 };
    int *t = a;
    fun(a, b, t);
    cout << *t << endl;        //输出为1,不是11
}
```

和上一题一样，这一题修改的也是指针的拷贝



3.指针操作

1).判断下面输出

```C++
int a = 0x1234;
char* p = (char*) &a;
*p == ?                    
*(p+1) == ?
*(p+2) == ?
```

**答：**大小端存储问题

如果是小端存储，则存储结果为 34 12 00 00；大端存储结果为 00 00 12 34；注意：这是16进制，两个16进制才表示一个字节，int 占用4个字节

由于p是char类型的指针，char型只占用一个字节，所以只会取存储的第一个字节的地址

假设是小端存储，则 *p = 0x34, *(p+1) = 0x12，*(p+2) = 0x00         可通过 printf("%x\n", *p)；打印16进制表示

如果是大端存储，则 *p = 0x00, *(p+1) = 0x00, *(p+2) = 0x12



2).下面变量a的结果为？

```C++
int a = (int)((int*)0 + 4);

//等价于
int *p = 0;
p = p + 4;
int a = (int)p;
```

**答：**(int \*)0 就相当于一个int型的指针，指向地址0；(int *)0 + 4 就是对一个指针加4，也就是向后移动了16字节 (一个int类型占4字节)

则相当于从地址0开始后移动了16个字节，结果 a = 16



3).下面输出为?

```C++
char buf[4] = { 0x12, 0x34, 0x56, 0x78 };
*(short*) &buf[3] = ?
```

**答：**由于short型占两个字节，则只会取前两个字节的地址，buf[3]为 0x 00 00 00 78

buf[3]的地址，如果小端为 0x 00 78；如果大端存储为 0x 00 00；       技巧：小端存储取后面的字节，大端存储取前面的字节





3.下列赋值语句错误的是，已知 a, b, c 都是 int 型变量

```C++
A. a = b = c * 0;
B. a = 1%(b = c == 2) + 3;		//由于"=="的运算符优先级比"="高，所以这里当且仅当c==2时此条语句才是正确的，否则取余的数会是0
C. a = 1 = (b = 1) = 1;			
D. a = (b = 0)*(c + 0);	
```

对C选项：由于 "=" 运算符的结合顺序为自右向左，b = 1, 1 = b 这是将一个左值赋值给右值，一定错误



4.构造函数的默认参数在定义和声明的地方只能出现一次，要么在声明处，要么在定义处；不可两处都存在

有默认构造函数则不能定义无参构造，否则会冲突

```C++
class Point {
public:
    Point(int m_x = 0, int m_y = 0) : x(m_x), y(m_y) {};    //默认参数要么出现在这，要么出现在下面实现语句
private:
    int x, y = 0;
};

Point::Point(int m_x, int m_y) {
    x = m_x, y = m_y;
}
```



5.基类指针指向派生类对象

```C++
class A {
public:
    int test() { std::cout << "A" << std::endl; }
};

class B : public A {
public:
    int test() { std::cout << "B" << std::endl; }
};

A *p = new A();
p->test();        //这不是多态，调用的是类A的test()函数
```

在派生类对象中含有与基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且也能将基类的指针或者引用绑定到派生类对象中的基类部分上

这种转换称为派生类到基类的类型转换；编译器会隐式的执行派生类到基类的类型转换

这种隐式特性意味着我们可以把派生类对象或者派生类引用用在需要基类引用的地方；同样也可以把派生类对象的指针用在需要基类指针的地方

之所以存在派生类向基类的类型转换就是因为每个派生类对象都包含有一个基类部分，而基类的指针或者引用可以绑定到该基类部分上

尽管派生类对象含有从基类继承来的成员，但是派生类并不能直接初始化这些成员；和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分；每个类控制它自己成员的初始化过程       （《Primer》P599）



6.空指针是否能够调用成员函数，能否调用虚函数？

```C++
class A {
public:
    void func1( ) {
        //_a = 1;
    }
    virtual void func2( ) {
    }

private:
     int _a = 10 ;
};

int main()
{
    A *p = nullptr;
    p->func1( );        //调用成功
    p->func2( );        //调用失败
    return 0;
}
```

**答：**

1.如果成员函数没有对类的成员进行任何操作（也就是没有用到this指针时），则类的空指针可以访问成员函数

对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。 当程序被编译之后，其成员函数地址便已确定好；

当调用p->func1( )； 这句话时，其实就是调用 A::func1(this)，也就是会隐含传入一个 this 指针用以指向当前的对象；而成员函数的地址在编译时就已经确定，需要注意的是，你用空指针调用成员函数，只是让 this 指针指向了空，所以空指针也是可以调用普通成员函数，只不过此时的 this 指针指向空而已，而且函数 fun1 函数体内并没有用到 this 指针，所以不会出现问题

当成员函数体内用到this指针时，如果你的this指针是空，那么程序就会崩溃。比如，如果把 "\_a=1; " 这句话放开，程序就会出问题，原因就是this指针指向空，当进行赋值的时候，编译器不知道这个成员变量是哪一个对象的，所以他不知道给哪个对象的 _a 赋值，因此就会出错

2.空指针不能调用虚函数

因为虚函数的调用需要借助虚表指针，而虚表指针则是通过 this 指针来实例化，由于 this 指针为空，当然虚表指针也就无法知道自己指向的哪一个对象，自然也就无法完成实例化



7.判断下面输出

```C++
class Test {
public:
    Test() { std::cout << "#"; }
    void* operator new[](size_t size) {        //重载new[]运算符
        void *p = malloc(size);
        return p;
    }
    void operator delete[](void *p) {        //重载delete[]运算符
        free(p);
    }
    ~Test() { std::cout << "*"; }
};

Test *p = new Test[5];      //输出 "#####"
delete[] p;                 //输出 "*****"
```

